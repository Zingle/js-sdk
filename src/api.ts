/* tslint:disable */
/* eslint-disable */
/**
 * Zingle API (Current)
 * Zingle Core API
 *
 * The version of the OpenAPI document: 2.0
 * Contact: support@zingleme.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AllContactsRecipient
 */
export interface AllContactsRecipient {
    /**
     * 
     * @type {string}
     * @memberof AllContactsRecipient
     */
    type?: AllContactsRecipientTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum AllContactsRecipientTypeEnum {
    AllContacts = 'allContacts'
}

/**
 * 
 * @export
 * @interface Attachment
 */
export interface Attachment {
    /**
     * base64 string
     * @type {string}
     * @memberof Attachment
     */
    content: string;
    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    mimeType: string;
    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    filename: string;
}
/**
 * 
 * @export
 * @interface ChannelInput
 */
export interface ChannelInput {
    /**
     * 
     * @type {string}
     * @memberof ChannelInput
     */
    type: ChannelInputTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ChannelInput
     */
    value: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ChannelInputTypeEnum {
    PhoneNumber = 'phone_number',
    Wechat = 'wechat',
    Line = 'line',
    FacebookMessenger = 'facebook_messenger',
    EmailAddress = 'email_address'
}

/**
 * 
 * @export
 * @interface Condition
 */
export interface Condition {
    /**
     * 
     * @type {string}
     * @memberof Condition
     */
    method?: string;
    /**
     * 
     * @type {string}
     * @memberof Condition
     */
    source?: string;
    /**
     * 
     * @type {string}
     * @memberof Condition
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface ConditionRecipient
 */
export interface ConditionRecipient {
    /**
     * 
     * @type {string}
     * @memberof ConditionRecipient
     */
    type: ConditionRecipientTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ConditionRecipient
     */
    fuzzySearchTerm?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ConditionRecipientTypeEnum {
    Conditions = 'conditions'
}

/**
 * 
 * @export
 * @interface ContactField
 */
export interface ContactField {
    /**
     * 
     * @type {string}
     * @memberof ContactField
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof ContactField
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ContactField
     */
    type: ContactFieldTypeEnum;
    /**
     * If specified, contact field input will be displayed as a dropdown in the Zingle interface.
     * @type {Set<string>}
     * @memberof ContactField
     */
    options?: Set<string>;
    /**
     * 
     * @type {string}
     * @memberof ContactField
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof ContactField
     */
    updatedAt: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ContactFieldTypeEnum {
    String = 'string',
    Date = 'date',
    Boolean = 'boolean',
    Time = 'time'
}

/**
 * 
 * @export
 * @interface ContactFieldInput
 */
export interface ContactFieldInput {
    /**
     * 
     * @type {string}
     * @memberof ContactFieldInput
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ContactFieldInput
     */
    type: ContactFieldInputTypeEnum;
    /**
     * If specified, contact field input will be displayed as a dropdown in the Zingle interface.
     * @type {Set<string>}
     * @memberof ContactFieldInput
     */
    options?: Set<string>;
}

/**
    * @export
    * @enum {string}
    */
export enum ContactFieldInputTypeEnum {
    String = 'string',
    Date = 'date',
    Boolean = 'boolean',
    Time = 'time'
}

/**
 * 
 * @export
 * @interface ContactFieldValueInput
 */
export interface ContactFieldValueInput {
    /**
     * 
     * @type {string}
     * @memberof ContactFieldValueInput
     */
    contactFieldName?: string;
    /**
     * Field value. Must be one 
     * @type {object}
     * @memberof ContactFieldValueInput
     */
    value?: object;
}
/**
 * 
 * @export
 * @interface ContactInput
 */
export interface ContactInput {
    /**
     * 
     * @type {string}
     * @memberof ContactInput
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactInput
     */
    lastName?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactInput
     */
    title?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ContactInput
     */
    tags?: Array<string>;
    /**
     * 
     * @type {Array<ChannelInput & object>}
     * @memberof ContactInput
     */
    channels?: Array<ChannelInput & object>;
    /**
     * You may optionally specify a unique ID for the contact.  If supplied, this may be used to query and update the contact.
     * @type {string}
     * @memberof ContactInput
     */
    externalId?: string;
    /**
     * 
     * @type {ContactInputConversationProperties}
     * @memberof ContactInput
     */
    conversationProperties?: ContactInputConversationProperties;
    /**
     * 
     * @type {string}
     * @memberof ContactInput
     */
    notes?: string;
    /**
     * 
     * @type {Array<ContactFieldValueInput>}
     * @memberof ContactInput
     */
    contactFields?: Array<ContactFieldValueInput>;
}
/**
 * 
 * @export
 * @interface ContactInputConversationProperties
 */
export interface ContactInputConversationProperties {
    /**
     * 
     * @type {boolean}
     * @memberof ContactInputConversationProperties
     */
    isClosed?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ContactInputConversationProperties
     */
    isUnread?: boolean;
    /**
     * Contact may be assigned to a user or team, but not both.
     * @type {string}
     * @memberof ContactInputConversationProperties
     */
    assignedToUserId?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactInputConversationProperties
     */
    assignedToTeamId?: string;
}
/**
 * 
 * @export
 * @interface ContactLog
 */
export interface ContactLog {
    /**
     * 
     * @type {string}
     * @memberof ContactLog
     */
    result?: ContactLogResultEnum;
    /**
     * 
     * @type {string}
     * @memberof ContactLog
     */
    action?: ContactLogActionEnum;
    /**
     * 
     * @type {string}
     * @memberof ContactLog
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactLog
     */
    phone?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactLog
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactLog
     */
    source?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactLog
     */
    receivedAt?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactLog
     */
    matchedOn?: ContactLogMatchedOnEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof ContactLog
     */
    errors?: Array<string>;
}

/**
    * @export
    * @enum {string}
    */
export enum ContactLogResultEnum {
    Success = 'success',
    Failure = 'failure',
    Warning = 'warning'
}
/**
    * @export
    * @enum {string}
    */
export enum ContactLogActionEnum {
    Created = 'created',
    Updated = 'updated',
    Ignored = 'ignored'
}
/**
    * @export
    * @enum {string}
    */
export enum ContactLogMatchedOnEnum {
    ExternalId = 'external_id',
    Phone = 'phone',
    Email = 'email'
}

/**
 * 
 * @export
 * @interface CreateFoo
 */
export interface CreateFoo {
    /**
     * 
     * @type {string}
     * @memberof CreateFoo
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateFoo
     */
    color?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateFoo
     */
    birthday?: string;
}
/**
 * 
 * @export
 * @interface EntityRecipient
 */
export interface EntityRecipient {
    /**
     * 
     * @type {string}
     * @memberof EntityRecipient
     */
    type: EntityRecipientTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof EntityRecipient
     */
    id: string;
}

/**
    * @export
    * @enum {string}
    */
export enum EntityRecipientTypeEnum {
    Contact = 'contact',
    Segment = 'segment',
    Tag = 'tag'
}

/**
 * 
 * @export
 * @interface ErrorFieldErrors
 */
export interface ErrorFieldErrors {
    /**
     * 
     * @type {string}
     * @memberof ErrorFieldErrors
     */
    field?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ErrorFieldErrors
     */
    errors?: Array<string>;
}
/**
 * 
 * @export
 * @interface Foo
 */
export interface Foo {
    /**
     * 
     * @type {string}
     * @memberof Foo
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Foo
     */
    color?: string;
    /**
     * 
     * @type {string}
     * @memberof Foo
     */
    birthday?: string;
    /**
     * 
     * @type {string}
     * @memberof Foo
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof Foo
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof Foo
     */
    updatedAt: string;
}
/**
 * 
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     * 
     * @type {string}
     * @memberof InlineObject
     */
    collection_id?: string;
}
/**
 * 
 * @export
 * @interface InlineObject1
 */
export interface InlineObject1 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject1
     */
    auth_token?: string;
}
/**
 * 
 * @export
 * @interface InlineObject10
 */
export interface InlineObject10 {
    /**
     * 
     * @type {number}
     * @memberof InlineObject10
     */
    desktop?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineObject10
     */
    mobile?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineObject10
     */
    email?: number;
}
/**
 * 
 * @export
 * @interface InlineObject11
 */
export interface InlineObject11 {
    /**
     * Either provider code or IDP id.
     * @type {string}
     * @memberof InlineObject11
     */
    provider: string;
    /**
     * Access code from successful oauth request.
     * @type {string}
     * @memberof InlineObject11
     */
    code: string;
}
/**
 * 
 * @export
 * @interface InlineObject12
 */
export interface InlineObject12 {
    /**
     * 
     * @type {number}
     * @memberof InlineObject12
     */
    beginAtRow?: number;
    /**
     * 
     * @type {object}
     * @memberof InlineObject12
     */
    mapping?: object;
}
/**
 * 
 * @export
 * @interface InlineObject13
 */
export interface InlineObject13 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject13
     */
    displayName: string;
}
/**
 * 
 * @export
 * @interface InlineObject14
 */
export interface InlineObject14 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject14
     */
    displayName?: string;
}
/**
 * 
 * @export
 * @interface InlineObject15
 */
export interface InlineObject15 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject15
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject15
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject15
     */
    lastName?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject15
     */
    role?: string;
}
/**
 * 
 * @export
 * @interface InlineObject16
 */
export interface InlineObject16 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject16
     */
    role?: string;
}
/**
 * 
 * @export
 * @interface InlineObject2
 */
export interface InlineObject2 {
    /**
     * 
     * @type {Set<string>}
     * @memberof InlineObject2
     */
    attendees?: Set<string>;
    /**
     * **We don\'t allow type updates**. This is because different types have differents fields. The type must be equal to the type that the calendar event already has assigned, otherwise, an error is thrown.
     * @type {string}
     * @memberof InlineObject2
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject2
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject2
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject2
     */
    startsAt?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject2
     */
    endsAt?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InlineObject2
     */
    allDay?: boolean;
}
/**
 * 
 * @export
 * @interface InlineObject3
 */
export interface InlineObject3 {
    /**
     * 
     * @type {Set<string>}
     * @memberof InlineObject3
     */
    attendees: Set<string>;
    /**
     * 
     * @type {string}
     * @memberof InlineObject3
     */
    type: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject3
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject3
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject3
     */
    startsAt: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject3
     */
    endsAt: string;
    /**
     * 
     * @type {boolean}
     * @memberof InlineObject3
     */
    allDay: boolean;
}
/**
 * 
 * @export
 * @interface InlineObject4
 */
export interface InlineObject4 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject4
     */
    code?: string;
}
/**
 * 
 * @export
 * @interface InlineObject5
 */
export interface InlineObject5 {
    /**
     * 
     * @type {number}
     * @memberof InlineObject5
     */
    beginAtRow?: number;
    /**
     * 
     * @type {Array<object>}
     * @memberof InlineObject5
     */
    headerMap?: Array<object>;
}
/**
 * 
 * @export
 * @interface InlineObject6
 */
export interface InlineObject6 {
    /**
     * 
     * @type {Array<ServicesServiceIdCalendarEventsBulkUpsertEvents>}
     * @memberof InlineObject6
     */
    events?: Array<ServicesServiceIdCalendarEventsBulkUpsertEvents>;
}
/**
 * 
 * @export
 * @interface InlineObject7
 */
export interface InlineObject7 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineObject7
     */
    notifyAdminUsers: boolean;
    /**
     * 
     * @type {Array<ProvisionAccounts>}
     * @memberof InlineObject7
     */
    accounts: Array<ProvisionAccounts>;
}
/**
 * 
 * @export
 * @interface InlineObject8
 */
export interface InlineObject8 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject8
     */
    body?: string;
}
/**
 * 
 * @export
 * @interface InlineObject9
 */
export interface InlineObject9 {
    /**
     * Should contact integer ids.
     * @type {Array<number>}
     * @memberof InlineObject9
     */
    contactIds?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof InlineObject9
     */
    searchTerm?: string;
    /**
     * 
     * @type {Array<ServicesServiceIdContactsExportConditions>}
     * @memberof InlineObject9
     */
    conditions?: Array<ServicesServiceIdContactsExportConditions>;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200
     */
    avatarUrl?: string;
    /**
     * 
     * @type {ObjectId}
     * @memberof InlineResponse200
     */
    object_id?: ObjectId;
    /**
     * 
     * @type {Timestamps}
     * @memberof InlineResponse200
     */
    timestamps?: Timestamps;
    /**
     * 
     * @type {UserProfileInput}
     * @memberof InlineResponse200
     */
    user_profile_input?: UserProfileInput;
}
/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2001
     */
    avatarUrl?: string;
    /**
     * 
     * @type {ContactInput}
     * @memberof InlineResponse2001
     */
    contact_input?: ContactInput;
    /**
     * 
     * @type {ObjectId}
     * @memberof InlineResponse2001
     */
    object_id?: ObjectId;
    /**
     * 
     * @type {Timestamps}
     * @memberof InlineResponse2001
     */
    timestamps?: Timestamps;
}
/**
 * 
 * @export
 * @interface InlineResponse20010
 */
export interface InlineResponse20010 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20010
     */
    total?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20010
     */
    currentPage?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20010
     */
    perPage?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20010
     */
    lastPage?: number;
    /**
     * 
     * @type {Array<InlineResponse20010Items>}
     * @memberof InlineResponse20010
     */
    items?: Array<InlineResponse20010Items>;
    /**
     * 
     * @type {InlineResponse20010Links}
     * @memberof InlineResponse20010
     */
    _links?: InlineResponse20010Links;
}
/**
 * 
 * @export
 * @interface InlineResponse20010Items
 */
export interface InlineResponse20010Items {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20010Items
     */
    status?: InlineResponse20010ItemsStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20010Items
     */
    expiredAt?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20010Items
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20010Items
     */
    updatedAt?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse20010ItemsStatusEnum {
    Active = 'active',
    Expired = 'expired',
    Revoked = 'revoked'
}

/**
 * 
 * @export
 * @interface InlineResponse20010Links
 */
export interface InlineResponse20010Links {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20010Links
     */
    self?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20011
 */
export interface InlineResponse20011 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20011
     */
    VIP?: boolean;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20011
     */
    FirstName?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20011
     */
    LastName?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20011
     */
    RoomNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20011
     */
    Email?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20011
     */
    ProfileID: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20011
     */
    Arrival?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20011
     */
    Departure?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20011
     */
    Status: InlineResponse20011StatusEnum;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20011
     */
    SpecialRequests?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20011
     */
    Salutation?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20011
     */
    Phone?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20011
     */
    Country?: string;
    /**
     * 
     * @type {ServicesServiceIdHotsosTestReservationsGroup}
     * @memberof InlineResponse20011
     */
    Group?: ServicesServiceIdHotsosTestReservationsGroup;
    /**
     * 
     * @type {ServicesServiceIdHotsosTestReservationsExtendedAttributes}
     * @memberof InlineResponse20011
     */
    ExtendedAttributes?: ServicesServiceIdHotsosTestReservationsExtendedAttributes;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20011
     */
    SortValue: string;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse20011StatusEnum {
    CheckedIn = 'CHECKED_IN',
    Cancelled = 'CANCELLED',
    CheckedOut = 'CHECKED_OUT',
    Reserved = 'RESERVED'
}

/**
 * 
 * @export
 * @interface InlineResponse20012
 */
export interface InlineResponse20012 {
    /**
     * 
     * @type {InlineResponse20012User}
     * @memberof InlineResponse20012
     */
    user?: InlineResponse20012User;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20012
     */
    desktop?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20012
     */
    mobile?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20012
     */
    email?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse20012User
 */
export interface InlineResponse20012User {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20012User
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20012User
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20012User
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20012User
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20012User
     */
    status?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20013
 */
export interface InlineResponse20013 {
    /**
     * JWT Token for user.
     * @type {string}
     * @memberof InlineResponse20013
     */
    token?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20014
 */
export interface InlineResponse20014 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20014
     */
    token?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20015
 */
export interface InlineResponse20015 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20015
     */
    currentPage?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20015
     */
    lastPage?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20015
     */
    perPage?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20015
     */
    total?: number;
    /**
     * 
     * @type {Array<InlineResponse20015Items>}
     * @memberof InlineResponse20015
     */
    items?: Array<InlineResponse20015Items>;
    /**
     * 
     * @type {InlineResponse20015Links}
     * @memberof InlineResponse20015
     */
    _links?: InlineResponse20015Links;
}
/**
 * 
 * @export
 * @interface InlineResponse20015Items
 */
export interface InlineResponse20015Items {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20015Items
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20015Items
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20015Items
     */
    updatedAt?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20015Items
     */
    displayName?: string;
    /**
     * 
     * @type {Array<InlineResponse20015Users>}
     * @memberof InlineResponse20015Items
     */
    users?: Array<InlineResponse20015Users>;
}
/**
 * 
 * @export
 * @interface InlineResponse20015Links
 */
export interface InlineResponse20015Links {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20015Links
     */
    self?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20015Users
 */
export interface InlineResponse20015Users {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20015Users
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20015Users
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20015Users
     */
    organizationId?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20015Users
     */
    roleId?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20015Users
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20015Users
     */
    uuid?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002
     */
    service_group_id?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2003
     */
    code?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2003
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2003
     */
    status?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2004
 */
export interface InlineResponse2004 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004
     */
    link?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2005
 */
export interface InlineResponse2005 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005
     */
    domainCode?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005
     */
    metadataUri?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005
     */
    issuerUri?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005
     */
    signOnUri?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005
     */
    logoutUri?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005
     */
    certificate?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2005
     */
    requireEmail?: boolean;
}
/**
 * 
 * @export
 * @interface InlineResponse2006
 */
export interface InlineResponse2006 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006
     */
    externalId?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006
     */
    startsAt?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006
     */
    endsAt?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2006
     */
    allDay?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineResponse2006
     */
    attendees?: Array<string>;
    /**
     * 
     * @type {ServicesServiceIdCalendarEventsType}
     * @memberof InlineResponse2006
     */
    type?: ServicesServiceIdCalendarEventsType;
}
/**
 * 
 * @export
 * @interface InlineResponse2007
 */
export interface InlineResponse2007 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2007
     */
    code?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2007
     */
    displayName?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2007
     */
    description?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2008
 */
export interface InlineResponse2008 {
    /**
     * 
     * @type {Array<object>}
     * @memberof InlineResponse2008
     */
    headers?: Array<object>;
    /**
     * 
     * @type {Array<object>}
     * @memberof InlineResponse2008
     */
    sample?: Array<object>;
}
/**
 * 
 * @export
 * @interface InlineResponse2009
 */
export interface InlineResponse2009 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2009
     */
    total?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2009
     */
    purchased?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse401
 */
export interface InlineResponse401 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse401
     */
    error?: string;
}
/**
 * 
 * @export
 * @interface Integration
 */
export interface Integration {
    /**
     * 
     * @type {string}
     * @memberof Integration
     */
    auth_token?: string;
    /**
     * 
     * @type {string}
     * @memberof Integration
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Integration
     */
    code?: string;
    /**
     * 
     * @type {string}
     * @memberof Integration
     */
    requires_auth_token?: string;
    /**
     * 
     * @type {string}
     * @memberof Integration
     */
    status?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Integration
     */
    allows_mapping_fields?: boolean;
}
/**
 * 
 * @export
 * @interface IntegrationAllOf
 */
export interface IntegrationAllOf {
    /**
     * 
     * @type {string}
     * @memberof IntegrationAllOf
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof IntegrationAllOf
     */
    code?: string;
    /**
     * 
     * @type {string}
     * @memberof IntegrationAllOf
     */
    requires_auth_token?: string;
    /**
     * 
     * @type {string}
     * @memberof IntegrationAllOf
     */
    auth_token?: string;
    /**
     * 
     * @type {string}
     * @memberof IntegrationAllOf
     */
    status?: string;
    /**
     * 
     * @type {boolean}
     * @memberof IntegrationAllOf
     */
    allows_mapping_fields?: boolean;
}
/**
 * 
 * @export
 * @interface IntegrationConfiguration
 */
export interface IntegrationConfiguration {
    /**
     * 
     * @type {string}
     * @memberof IntegrationConfiguration
     */
    code?: string;
    /**
     * 
     * @type {string}
     * @memberof IntegrationConfiguration
     */
    value?: string;
    /**
     * 
     * @type {string}
     * @memberof IntegrationConfiguration
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof IntegrationConfiguration
     */
    field_type?: string;
}
/**
 * 
 * @export
 * @interface IntegrationConfigurationAllOf
 */
export interface IntegrationConfigurationAllOf {
    /**
     * 
     * @type {string}
     * @memberof IntegrationConfigurationAllOf
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof IntegrationConfigurationAllOf
     */
    field_type?: string;
}
/**
 * 
 * @export
 * @interface IntegrationConfigurationInput
 */
export interface IntegrationConfigurationInput {
    /**
     * 
     * @type {string}
     * @memberof IntegrationConfigurationInput
     */
    code?: string;
    /**
     * 
     * @type {string}
     * @memberof IntegrationConfigurationInput
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface IntegrationFieldMapping
 */
export interface IntegrationFieldMapping {
    /**
     * 
     * @type {number}
     * @memberof IntegrationFieldMapping
     */
    begin_at_row?: number;
    /**
     * Array of column headers (keys) mapped to Zingle contact fields (values)
     * @type {object}
     * @memberof IntegrationFieldMapping
     */
    column_field_mapping?: object;
    /**
     * 
     * @type {string}
     * @memberof IntegrationFieldMapping
     */
    last_received_at?: string;
    /**
     * 
     * @type {IntegrationFieldMappingAllOfSampleData}
     * @memberof IntegrationFieldMapping
     */
    sample_data?: IntegrationFieldMappingAllOfSampleData;
    /**
     * 
     * @type {string}
     * @memberof IntegrationFieldMapping
     */
    status?: IntegrationFieldMappingStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum IntegrationFieldMappingStatusEnum {
    Receipt = 'awaiting_receipt',
    Configuration = 'awaiting_configuration'
}

/**
 * 
 * @export
 * @interface IntegrationFieldMappingAllOf
 */
export interface IntegrationFieldMappingAllOf {
    /**
     * 
     * @type {string}
     * @memberof IntegrationFieldMappingAllOf
     */
    last_received_at?: string;
    /**
     * 
     * @type {IntegrationFieldMappingAllOfSampleData}
     * @memberof IntegrationFieldMappingAllOf
     */
    sample_data?: IntegrationFieldMappingAllOfSampleData;
    /**
     * 
     * @type {string}
     * @memberof IntegrationFieldMappingAllOf
     */
    status?: IntegrationFieldMappingAllOfStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum IntegrationFieldMappingAllOfStatusEnum {
    Receipt = 'awaiting_receipt',
    Configuration = 'awaiting_configuration'
}

/**
 * 
 * @export
 * @interface IntegrationFieldMappingAllOfSampleData
 */
export interface IntegrationFieldMappingAllOfSampleData {
    /**
     * 
     * @type {Array<string>}
     * @memberof IntegrationFieldMappingAllOfSampleData
     */
    headers?: Array<string>;
    /**
     * 
     * @type {Array<object>}
     * @memberof IntegrationFieldMappingAllOfSampleData
     */
    rows?: Array<object>;
}
/**
 * 
 * @export
 * @interface IntegrationFieldMappingInput
 */
export interface IntegrationFieldMappingInput {
    /**
     * 
     * @type {number}
     * @memberof IntegrationFieldMappingInput
     */
    begin_at_row?: number;
    /**
     * Array of column headers (keys) mapped to Zingle contact fields (values)
     * @type {object}
     * @memberof IntegrationFieldMappingInput
     */
    column_field_mapping?: object;
}
/**
 * 
 * @export
 * @interface IntegrationInput
 */
export interface IntegrationInput {
    /**
     * 
     * @type {string}
     * @memberof IntegrationInput
     */
    auth_token?: string;
}
/**
 * 
 * @export
 * @interface MessageCategory
 */
export interface MessageCategory {
    /**
     * 
     * @type {string}
     * @memberof MessageCategory
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof MessageCategory
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof MessageCategory
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof MessageCategory
     */
    updatedAt: string;
}
/**
 * 
 * @export
 * @interface MessageCategoryInput
 */
export interface MessageCategoryInput {
    /**
     * 
     * @type {string}
     * @memberof MessageCategoryInput
     */
    name: string;
}
/**
 * 
 * @export
 * @interface MessageInput
 */
export interface MessageInput {
    /**
     * 
     * @type {Array<object>}
     * @memberof MessageInput
     */
    recipients?: Array<object>;
    /**
     * 
     * @type {string}
     * @memberof MessageInput
     */
    body?: string;
    /**
     * 
     * @type {Array<Attachment>}
     * @memberof MessageInput
     */
    attachments?: Array<Attachment>;
    /**
     * 
     * @type {string}
     * @memberof MessageInput
     */
    deduplicationId?: string;
    /**
     * 
     * @type {number}
     * @memberof MessageInput
     */
    delayMinutes?: number;
    /**
     * 
     * @type {string}
     * @memberof MessageInput
     */
    templateId?: string;
    /**
     * 
     * @type {string}
     * @memberof MessageInput
     */
    sourceLanguage?: string;
    /**
     * 
     * @type {string}
     * @memberof MessageInput
     */
    destinationLanguage?: string;
}
/**
 * 
 * @export
 * @interface MessageInputAllOf
 */
export interface MessageInputAllOf {
    /**
     * 
     * @type {Array<object>}
     * @memberof MessageInputAllOf
     */
    recipients?: Array<object>;
}
/**
 * 
 * @export
 * @interface MessageInputAllOf1
 */
export interface MessageInputAllOf1 {
    /**
     * 
     * @type {string}
     * @memberof MessageInputAllOf1
     */
    body?: string;
    /**
     * 
     * @type {Array<Attachment>}
     * @memberof MessageInputAllOf1
     */
    attachments?: Array<Attachment>;
    /**
     * 
     * @type {string}
     * @memberof MessageInputAllOf1
     */
    deduplicationId?: string;
    /**
     * 
     * @type {number}
     * @memberof MessageInputAllOf1
     */
    delayMinutes?: number;
    /**
     * 
     * @type {string}
     * @memberof MessageInputAllOf1
     */
    templateId?: string;
    /**
     * 
     * @type {string}
     * @memberof MessageInputAllOf1
     */
    sourceLanguage?: string;
    /**
     * 
     * @type {string}
     * @memberof MessageInputAllOf1
     */
    destinationLanguage?: string;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    code?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    description?: string;
    /**
     * 
     * @type {Array<ErrorFieldErrors>}
     * @memberof ModelError
     */
    fieldErrors?: Array<ErrorFieldErrors>;
}
/**
 * 
 * @export
 * @interface ObjectId
 */
export interface ObjectId {
    /**
     * 
     * @type {string}
     * @memberof ObjectId
     */
    id: string;
}
/**
 * 
 * @export
 * @interface PhoneNumberInput
 */
export interface PhoneNumberInput {
    /**
     * 
     * @type {string}
     * @memberof PhoneNumberInput
     */
    country: string;
    /**
     * 
     * @type {string}
     * @memberof PhoneNumberInput
     */
    phoneNumber: string;
    /**
     * 
     * @type {string}
     * @memberof PhoneNumberInput
     */
    provider: PhoneNumberInputProviderEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum PhoneNumberInputProviderEnum {
    Bandwidth = 'bandwidth',
    TwilioPhoneNumber = 'twilio_phone_number'
}

/**
 * 
 * @export
 * @interface PhoneRecipient
 */
export interface PhoneRecipient {
    /**
     * 
     * @type {string}
     * @memberof PhoneRecipient
     */
    type: PhoneRecipientTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof PhoneRecipient
     */
    value: string;
}

/**
    * @export
    * @enum {string}
    */
export enum PhoneRecipientTypeEnum {
    Phone = 'phone',
    Wechat = 'wechat',
    Facebook = 'facebook',
    Line = 'line',
    Chat = 'chat',
    Email = 'email'
}

/**
 * 
 * @export
 * @interface ProfileInput
 */
export interface ProfileInput {
    /**
     * 
     * @type {string}
     * @memberof ProfileInput
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof ProfileInput
     */
    lastName?: string;
    /**
     * 
     * @type {string}
     * @memberof ProfileInput
     */
    hotsosLogin?: string;
    /**
     * 
     * @type {string}
     * @memberof ProfileInput
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof ProfileInput
     */
    signature?: string;
    /**
     * 
     * @type {string}
     * @memberof ProfileInput
     */
    phone?: string;
    /**
     * 
     * @type {string}
     * @memberof ProfileInput
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof ProfileInput
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof ProfileInput
     */
    avatarUrl?: string;
    /**
     * 
     * @type {Array<ObjectId>}
     * @memberof ProfileInput
     */
    teams?: Array<ObjectId>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProfileInput
     */
    privileges?: Array<string>;
}
/**
 * 
 * @export
 * @interface ProvisionAccounts
 */
export interface ProvisionAccounts {
    /**
     * 
     * @type {string}
     * @memberof ProvisionAccounts
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof ProvisionAccounts
     */
    billingDayOfMonth: number;
    /**
     * 
     * @type {string}
     * @memberof ProvisionAccounts
     */
    salesforceId: string;
    /**
     * 
     * @type {string}
     * @memberof ProvisionAccounts
     */
    industry?: string;
}
/**
 * 
 * @export
 * @interface RecordRequest
 */
export interface RecordRequest {
    /**
     * 
     * @type {string}
     * @memberof RecordRequest
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof RecordRequest
     */
    lastName?: string;
    /**
     * 
     * @type {string}
     * @memberof RecordRequest
     */
    title?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RecordRequest
     */
    tags?: Array<string>;
    /**
     * 
     * @type {Array<ChannelInput & object>}
     * @memberof RecordRequest
     */
    channels?: Array<ChannelInput & object>;
    /**
     * You may optionally specify a unique ID for the contact.  If supplied, this may be used to query and update the contact.
     * @type {string}
     * @memberof RecordRequest
     */
    externalId?: string;
    /**
     * 
     * @type {ContactInputConversationProperties}
     * @memberof RecordRequest
     */
    conversationProperties?: ContactInputConversationProperties;
    /**
     * 
     * @type {string}
     * @memberof RecordRequest
     */
    notes?: string;
    /**
     * 
     * @type {Array<ContactFieldValueInput>}
     * @memberof RecordRequest
     */
    contactFields?: Array<ContactFieldValueInput>;
    /**
     * 
     * @type {Attachment}
     * @memberof RecordRequest
     */
    avatar?: Attachment;
}
/**
 * 
 * @export
 * @interface Segment
 */
export interface Segment {
    /**
     * 
     * @type {string}
     * @memberof Segment
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof Segment
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Segment
     */
    backgroundColor: string;
    /**
     * 
     * @type {string}
     * @memberof Segment
     */
    textColor: string;
    /**
     * 
     * @type {Array<Condition>}
     * @memberof Segment
     */
    conditions: Array<Condition>;
    /**
     * 
     * @type {string}
     * @memberof Segment
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof Segment
     */
    updatedAt: string;
}
/**
 * 
 * @export
 * @interface SegmentInput
 */
export interface SegmentInput {
    /**
     * 
     * @type {string}
     * @memberof SegmentInput
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof SegmentInput
     */
    backgroundColor: string;
    /**
     * 
     * @type {string}
     * @memberof SegmentInput
     */
    textColor: string;
    /**
     * 
     * @type {Array<Condition>}
     * @memberof SegmentInput
     */
    conditions: Array<Condition>;
}
/**
 * 
 * @export
 * @interface ServiceChannelInput
 */
export interface ServiceChannelInput {
    /**
     * 
     * @type {string}
     * @memberof ServiceChannelInput
     */
    channel_type_code: ServiceChannelInputChannelTypeCodeEnum;
    /**
     * 
     * @type {string}
     * @memberof ServiceChannelInput
     */
    channel_value: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceChannelInput
     */
    phone_number_carrier_code: ServiceChannelInputPhoneNumberCarrierCodeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ServiceChannelInputChannelTypeCodeEnum {
    PhoneNumber = 'phone_number'
}
/**
    * @export
    * @enum {string}
    */
export enum ServiceChannelInputPhoneNumberCarrierCodeEnum {
    Bandwidth = 'bandwidth',
    TwilioPhoneNumber = 'twilio_phone_number'
}

/**
 * 
 * @export
 * @interface ServiceCollection
 */
export interface ServiceCollection {
    /**
     * 
     * @type {string}
     * @memberof ServiceCollection
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceCollection
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceCollection
     */
    description?: string;
    /**
     * 
     * @type {Array<ServiceCollection>}
     * @memberof ServiceCollection
     */
    fields?: Array<ServiceCollection>;
}
/**
 * 
 * @export
 * @interface ServiceCollectionAllOf
 */
export interface ServiceCollectionAllOf {
    /**
     * 
     * @type {Array<ServiceCollection>}
     * @memberof ServiceCollectionAllOf
     */
    fields?: Array<ServiceCollection>;
}
/**
 * 
 * @export
 * @interface ServiceCollectionField
 */
export interface ServiceCollectionField {
    /**
     * 
     * @type {string}
     * @memberof ServiceCollectionField
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceCollectionField
     */
    name: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ServiceCollectionField
     */
    values?: Array<string>;
}
/**
 * 
 * @export
 * @interface ServiceCollectionFieldAllOf
 */
export interface ServiceCollectionFieldAllOf {
    /**
     * 
     * @type {Array<string>}
     * @memberof ServiceCollectionFieldAllOf
     */
    values?: Array<string>;
}
/**
 * 
 * @export
 * @interface ServiceCollectionFieldInput
 */
export interface ServiceCollectionFieldInput {
    /**
     * 
     * @type {string}
     * @memberof ServiceCollectionFieldInput
     */
    name: string;
}
/**
 * 
 * @export
 * @interface ServiceCollectionFieldValue
 */
export interface ServiceCollectionFieldValue {
    /**
     * 
     * @type {string}
     * @memberof ServiceCollectionFieldValue
     */
    field_id: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceCollectionFieldValue
     */
    value: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceCollectionFieldValue
     */
    field_name?: string;
}
/**
 * 
 * @export
 * @interface ServiceCollectionFieldValueAllOf
 */
export interface ServiceCollectionFieldValueAllOf {
    /**
     * 
     * @type {string}
     * @memberof ServiceCollectionFieldValueAllOf
     */
    field_name?: string;
}
/**
 * 
 * @export
 * @interface ServiceCollectionFieldValueInput
 */
export interface ServiceCollectionFieldValueInput {
    /**
     * 
     * @type {string}
     * @memberof ServiceCollectionFieldValueInput
     */
    field_id: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceCollectionFieldValueInput
     */
    value: string;
}
/**
 * 
 * @export
 * @interface ServiceCollectionInput
 */
export interface ServiceCollectionInput {
    /**
     * 
     * @type {string}
     * @memberof ServiceCollectionInput
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceCollectionInput
     */
    description?: string;
}
/**
 * 
 * @export
 * @interface ServiceCollectionService
 */
export interface ServiceCollectionService {
    /**
     * 
     * @type {string}
     * @memberof ServiceCollectionService
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceCollectionService
     */
    name?: string;
    /**
     * 
     * @type {ServiceCollectionServiceInput & object}
     * @memberof ServiceCollectionService
     */
    field_values?: ServiceCollectionServiceInput & object;
}
/**
 * 
 * @export
 * @interface ServiceCollectionServiceInput
 */
export interface ServiceCollectionServiceInput {
    /**
     * 
     * @type {Array<ServiceCollectionFieldValueInput>}
     * @memberof ServiceCollectionServiceInput
     */
    field_values?: Array<ServiceCollectionFieldValueInput>;
}
/**
 * 
 * @export
 * @interface ServicesServiceIdCalendarEventsBulkUpsertEvents
 */
export interface ServicesServiceIdCalendarEventsBulkUpsertEvents {
    /**
     * Create new calendar event if not present
     * @type {string}
     * @memberof ServicesServiceIdCalendarEventsBulkUpsertEvents
     */
    uuid?: string;
    /**
     * 
     * @type {Set<object>}
     * @memberof ServicesServiceIdCalendarEventsBulkUpsertEvents
     */
    attendees?: Set<object>;
    /**
     * 
     * @type {string}
     * @memberof ServicesServiceIdCalendarEventsBulkUpsertEvents
     */
    title?: string;
    /**
     * **We don\'t allow type updates**. This is because different types have differents fields. In an update, the type must be equal to the type that the calendar event already has assigned, otherwise, an error is thrown.
     * @type {string}
     * @memberof ServicesServiceIdCalendarEventsBulkUpsertEvents
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof ServicesServiceIdCalendarEventsBulkUpsertEvents
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof ServicesServiceIdCalendarEventsBulkUpsertEvents
     */
    startsAt?: string;
    /**
     * 
     * @type {string}
     * @memberof ServicesServiceIdCalendarEventsBulkUpsertEvents
     */
    endsAt?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ServicesServiceIdCalendarEventsBulkUpsertEvents
     */
    allDay?: boolean;
}
/**
 * 
 * @export
 * @interface ServicesServiceIdCalendarEventsType
 */
export interface ServicesServiceIdCalendarEventsType {
    /**
     * 
     * @type {number}
     * @memberof ServicesServiceIdCalendarEventsType
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ServicesServiceIdCalendarEventsType
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof ServicesServiceIdCalendarEventsType
     */
    name?: string;
    /**
     * 
     * @type {Array<ServicesServiceIdCalendarEventsTypeFields>}
     * @memberof ServicesServiceIdCalendarEventsType
     */
    fields?: Array<ServicesServiceIdCalendarEventsTypeFields>;
}
/**
 * 
 * @export
 * @interface ServicesServiceIdCalendarEventsTypeFields
 */
export interface ServicesServiceIdCalendarEventsTypeFields {
    /**
     * 
     * @type {string}
     * @memberof ServicesServiceIdCalendarEventsTypeFields
     */
    code?: string;
    /**
     * 
     * @type {string}
     * @memberof ServicesServiceIdCalendarEventsTypeFields
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof ServicesServiceIdCalendarEventsTypeFields
     */
    label?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ServicesServiceIdCalendarEventsTypeFields
     */
    template?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ServicesServiceIdCalendarEventsTypeFields
     */
    eventType?: string;
}
/**
 * 
 * @export
 * @interface ServicesServiceIdContactsExportConditions
 */
export interface ServicesServiceIdContactsExportConditions {
    /**
     * 
     * @type {string}
     * @memberof ServicesServiceIdContactsExportConditions
     */
    comparisonMethodCode?: string;
    /**
     * 
     * @type {string}
     * @memberof ServicesServiceIdContactsExportConditions
     */
    comparisonSource?: string;
}
/**
 * 
 * @export
 * @interface ServicesServiceIdHotsosTestReservationsExtendedAttributes
 */
export interface ServicesServiceIdHotsosTestReservationsExtendedAttributes {
    /**
     * 
     * @type {ServicesServiceIdHotsosTestReservationsExtendedAttributesExtendedAttribute}
     * @memberof ServicesServiceIdHotsosTestReservationsExtendedAttributes
     */
    ExtendedAttribute?: ServicesServiceIdHotsosTestReservationsExtendedAttributesExtendedAttribute;
}
/**
 * 
 * @export
 * @interface ServicesServiceIdHotsosTestReservationsExtendedAttributesExtendedAttribute
 */
export interface ServicesServiceIdHotsosTestReservationsExtendedAttributesExtendedAttribute {
    /**
     * 
     * @type {string}
     * @memberof ServicesServiceIdHotsosTestReservationsExtendedAttributesExtendedAttribute
     */
    Name?: ServicesServiceIdHotsosTestReservationsExtendedAttributesExtendedAttributeNameEnum;
    /**
     * 
     * @type {ServicesServiceIdHotsosTestReservationsExtendedAttributesExtendedAttributeValue}
     * @memberof ServicesServiceIdHotsosTestReservationsExtendedAttributesExtendedAttribute
     */
    Value?: ServicesServiceIdHotsosTestReservationsExtendedAttributesExtendedAttributeValue;
}

/**
    * @export
    * @enum {string}
    */
export enum ServicesServiceIdHotsosTestReservationsExtendedAttributesExtendedAttributeNameEnum {
    Home = 'HOME',
    Mobile = 'MOBILE',
    Business = 'BUSINESS'
}

/**
 * 
 * @export
 * @interface ServicesServiceIdHotsosTestReservationsExtendedAttributesExtendedAttributeValue
 */
export interface ServicesServiceIdHotsosTestReservationsExtendedAttributesExtendedAttributeValue {
    /**
     * Phone Number
     * @type {string}
     * @memberof ServicesServiceIdHotsosTestReservationsExtendedAttributesExtendedAttributeValue
     */
    text?: string;
}
/**
 * 
 * @export
 * @interface ServicesServiceIdHotsosTestReservationsGroup
 */
export interface ServicesServiceIdHotsosTestReservationsGroup {
    /**
     * 
     * @type {string}
     * @memberof ServicesServiceIdHotsosTestReservationsGroup
     */
    ID?: string;
}
/**
 * 
 * @export
 * @interface SimpleIdp
 */
export interface SimpleIdp {
    /**
     * 
     * @type {string}
     * @memberof SimpleIdp
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof SimpleIdp
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof SimpleIdp
     */
    domainCode?: string;
    /**
     * 
     * @type {string}
     * @memberof SimpleIdp
     */
    metadataUri?: string;
    /**
     * 
     * @type {string}
     * @memberof SimpleIdp
     */
    issuerUri?: string;
    /**
     * 
     * @type {string}
     * @memberof SimpleIdp
     */
    signOnUri?: string;
    /**
     * 
     * @type {string}
     * @memberof SimpleIdp
     */
    logoutUri?: string;
    /**
     * 
     * @type {string}
     * @memberof SimpleIdp
     */
    certificate?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SimpleIdp
     */
    requireEmail?: boolean;
}
/**
 * 
 * @export
 * @interface Tag
 */
export interface Tag {
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    name: string;
    /**
     * Hex String
     * @type {string}
     * @memberof Tag
     */
    textColor: string;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    backgroundColor?: string;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    updatedAt: string;
}
/**
 * 
 * @export
 * @interface TagInput
 */
export interface TagInput {
    /**
     * 
     * @type {string}
     * @memberof TagInput
     */
    name: string;
    /**
     * Hex String
     * @type {string}
     * @memberof TagInput
     */
    textColor: string;
    /**
     * 
     * @type {string}
     * @memberof TagInput
     */
    backgroundColor?: string;
}
/**
 * 
 * @export
 * @interface Template
 */
export interface Template {
    /**
     * 
     * @type {string}
     * @memberof Template
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof Template
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Template
     */
    body: string;
    /**
     * 
     * @type {string}
     * @memberof Template
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof Template
     */
    updatedAt: string;
}
/**
 * 
 * @export
 * @interface TemplateInput
 */
export interface TemplateInput {
    /**
     * 
     * @type {string}
     * @memberof TemplateInput
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof TemplateInput
     */
    body: string;
}
/**
 * 
 * @export
 * @interface Timestamps
 */
export interface Timestamps {
    /**
     * 
     * @type {string}
     * @memberof Timestamps
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof Timestamps
     */
    updatedAt: string;
}
/**
 * 
 * @export
 * @interface UpdateRequest
 */
export interface UpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateRequest
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateRequest
     */
    lastName?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateRequest
     */
    hotsosLogin?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateRequest
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateRequest
     */
    signature?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateRequest
     */
    phone?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateRequest
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateRequest
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateRequest
     */
    avatarUrl?: string;
    /**
     * 
     * @type {Array<ObjectId>}
     * @memberof UpdateRequest
     */
    teams?: Array<ObjectId>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateRequest
     */
    privileges?: Array<string>;
    /**
     * 
     * @type {Attachment}
     * @memberof UpdateRequest
     */
    avatar?: Attachment;
}
/**
 * 
 * @export
 * @interface UpdateRequestAllOf
 */
export interface UpdateRequestAllOf {
    /**
     * 
     * @type {Attachment}
     * @memberof UpdateRequestAllOf
     */
    avatar?: Attachment;
}
/**
 * 
 * @export
 * @interface UploadRequest
 */
export interface UploadRequest {
    /**
     * 
     * @type {string}
     * @memberof UploadRequest
     */
    file?: string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    lastName: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    hotsosLogin?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    signature?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    phone?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    avatarUrl?: string;
    /**
     * 
     * @type {Array<ObjectId>}
     * @memberof User
     */
    teams?: Array<ObjectId>;
    /**
     * 
     * @type {Array<string>}
     * @memberof User
     */
    privileges?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    updatedAt: string;
}
/**
 * 
 * @export
 * @interface UserCreateInput
 */
export interface UserCreateInput {
    /**
     * 
     * @type {string}
     * @memberof UserCreateInput
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof UserCreateInput
     */
    uiRole: UserCreateInputUiRoleEnum;
    /**
     * 
     * @type {string}
     * @memberof UserCreateInput
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCreateInput
     */
    lastName?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCreateInput
     */
    email?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum UserCreateInputUiRoleEnum {
    Administrator = 'dashboard_administrator',
    Standard = 'dashboard_standard',
    StandardWithBulkMessaging = 'dashboard_standard_with_bulk_messaging',
    StandardWithContactDeletion = 'dashboard_standard_with_contact_deletion',
    StandardWithAnalytics = 'dashboard_standard_with_analytics',
    StandardWithBulkMessagingWithContactDeletion = 'dashboard_standard_with_bulk_messaging_with_contact_deletion',
    StandardWithBulkMessagingWithAnalytics = 'dashboard_standard_with_bulk_messaging_with_analytics',
    StandardWithBulkMessagingWithContactDeletionWithAnalytics = 'dashboard_standard_with_bulk_messaging_with_contact_deletion_with_analytics',
    StandardWithContactDeletionWithAnalytics = 'dashboard_standard_with_contact_deletion_with_analytics',
    StandardWithUserManagement = 'dashboard_standard_with_user_management',
    StandardWithAnalyticsWithUserManagement = 'dashboard_standard_with_analytics_with_user_management',
    StandardWithBulkMessagingWithUserManagement = 'dashboard_standard_with_bulk_messaging_with_user_management',
    StandardWithBulkMessagingWithAnalyticsWithUserManagement = 'dashboard_standard_with_bulk_messaging_with_analytics_with_user_management',
    StandardWithBulkMessagingWithContactDeletionWithUserManagement = 'dashboard_standard_with_bulk_messaging_with_contact_deletion_with_user_management',
    StandardWithBulkMessagingWithContactDeletionWithAnalyticsWithUserManagement = 'dashboard_standard_with_bulk_messaging_with_contact_deletion_with_analytics_with_user_management',
    StandardWithContactDeletionWithUserManagement = 'dashboard_standard_with_contact_deletion_with_user_management',
    StandardWithContactDeletionWithAnalyticsWithUserManagement = 'dashboard_standard_with_contact_deletion_with_analytics_with_user_management'
}

/**
 * 
 * @export
 * @interface UserProfileInput
 */
export interface UserProfileInput {
    /**
     * 
     * @type {string}
     * @memberof UserProfileInput
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileInput
     */
    lastName: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileInput
     */
    hotsosLogin?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileInput
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileInput
     */
    signature?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileInput
     */
    phone?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileInput
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileInput
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileInput
     */
    avatarUrl?: string;
    /**
     * 
     * @type {Array<ObjectId>}
     * @memberof UserProfileInput
     */
    teams?: Array<ObjectId>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserProfileInput
     */
    privileges?: Array<string>;
}
/**
 * 
 * @export
 * @interface Webhook
 */
export interface Webhook {
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    url?: string;
    /**
     * 
     * @type {Array<WebhookInputHeaders>}
     * @memberof Webhook
     */
    headers?: Array<WebhookInputHeaders>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Webhook
     */
    events?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof Webhook
     */
    enabled?: boolean;
}
/**
 * 
 * @export
 * @interface WebhookInput
 */
export interface WebhookInput {
    /**
     * 
     * @type {string}
     * @memberof WebhookInput
     */
    url?: string;
    /**
     * 
     * @type {Array<WebhookInputHeaders>}
     * @memberof WebhookInput
     */
    headers?: Array<WebhookInputHeaders>;
    /**
     * 
     * @type {Array<string>}
     * @memberof WebhookInput
     */
    events?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof WebhookInput
     */
    enabled?: boolean;
}
/**
 * 
 * @export
 * @interface WebhookInputHeaders
 */
export interface WebhookInputHeaders {
    /**
     * 
     * @type {string}
     * @memberof WebhookInputHeaders
     */
    key?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookInputHeaders
     */
    value?: string;
}

/**
 * AnalyticsApi - axios parameter creator
 * @export
 */
export const AnalyticsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Build a group of services from an array of collection properties
         * @summary Create Analytics Service Group
         * @param {InlineObject} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnalyticsServiceGroup: async (body?: InlineObject, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/analytics/service-group`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get List of Mode Analytics Reports
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModeReports: async (serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('getModeReports', 'serviceId', serviceId)
            const localVarPath = `/services/{serviceId}/analytics/report-list`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sign Mode Analytics URL
         * @param {string} serviceId 
         * @param {string} [reportId] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signModeUrl: async (serviceId: string, reportId?: string, startDate?: string, endDate?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('signModeUrl', 'serviceId', serviceId)
            const localVarPath = `/services/{serviceId}/analytics/sign-url`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (reportId !== undefined) {
                localVarQueryParameter['report_id'] = reportId;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnalyticsApi - functional programming interface
 * @export
 */
export const AnalyticsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AnalyticsApiAxiosParamCreator(configuration)
    return {
        /**
         * Build a group of services from an array of collection properties
         * @summary Create Analytics Service Group
         * @param {InlineObject} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAnalyticsServiceGroup(body?: InlineObject, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAnalyticsServiceGroup(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get List of Mode Analytics Reports
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getModeReports(serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getModeReports(serviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Sign Mode Analytics URL
         * @param {string} serviceId 
         * @param {string} [reportId] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signModeUrl(serviceId: string, reportId?: string, startDate?: string, endDate?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signModeUrl(serviceId, reportId, startDate, endDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AnalyticsApi - factory interface
 * @export
 */
export const AnalyticsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AnalyticsApiFp(configuration)
    return {
        /**
         * Build a group of services from an array of collection properties
         * @summary Create Analytics Service Group
         * @param {InlineObject} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnalyticsServiceGroup(body?: InlineObject, options?: any): AxiosPromise<InlineResponse2002> {
            return localVarFp.createAnalyticsServiceGroup(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get List of Mode Analytics Reports
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModeReports(serviceId: string, options?: any): AxiosPromise<object> {
            return localVarFp.getModeReports(serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sign Mode Analytics URL
         * @param {string} serviceId 
         * @param {string} [reportId] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signModeUrl(serviceId: string, reportId?: string, startDate?: string, endDate?: string, options?: any): AxiosPromise<object> {
            return localVarFp.signModeUrl(serviceId, reportId, startDate, endDate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AnalyticsApi - object-oriented interface
 * @export
 * @class AnalyticsApi
 * @extends {BaseAPI}
 */
export class AnalyticsApi extends BaseAPI {
    /**
     * Build a group of services from an array of collection properties
     * @summary Create Analytics Service Group
     * @param {InlineObject} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public createAnalyticsServiceGroup(body?: InlineObject, options?: any) {
        return AnalyticsApiFp(this.configuration).createAnalyticsServiceGroup(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get List of Mode Analytics Reports
     * @param {string} serviceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public getModeReports(serviceId: string, options?: any) {
        return AnalyticsApiFp(this.configuration).getModeReports(serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sign Mode Analytics URL
     * @param {string} serviceId 
     * @param {string} [reportId] 
     * @param {string} [startDate] 
     * @param {string} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public signModeUrl(serviceId: string, reportId?: string, startDate?: string, endDate?: string, options?: any) {
        return AnalyticsApiFp(this.configuration).signModeUrl(serviceId, reportId, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BillingApi - axios parameter creator
 * @export
 */
export const BillingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Current usage
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesServiceIdUsageGet: async (serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('servicesServiceIdUsageGet', 'serviceId', serviceId)
            const localVarPath = `/services/{serviceId}/usage`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BillingApi - functional programming interface
 * @export
 */
export const BillingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BillingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Current usage
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async servicesServiceIdUsageGet(serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2009>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicesServiceIdUsageGet(serviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BillingApi - factory interface
 * @export
 */
export const BillingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BillingApiFp(configuration)
    return {
        /**
         * 
         * @summary Current usage
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesServiceIdUsageGet(serviceId: string, options?: any): AxiosPromise<InlineResponse2009> {
            return localVarFp.servicesServiceIdUsageGet(serviceId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BillingApi - object-oriented interface
 * @export
 * @class BillingApi
 * @extends {BaseAPI}
 */
export class BillingApi extends BaseAPI {
    /**
     * 
     * @summary Current usage
     * @param {string} serviceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public servicesServiceIdUsageGet(serviceId: string, options?: any) {
        return BillingApiFp(this.configuration).servicesServiceIdUsageGet(serviceId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CSVImportApi - axios parameter creator
 * @export
 */
export const CSVImportApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Process last updated CSV
         * @param {string} serviceId 
         * @param {InlineObject5} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesServiceIdCsvImportProcessPost: async (serviceId: string, body?: InlineObject5, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('servicesServiceIdCsvImportProcessPost', 'serviceId', serviceId)
            const localVarPath = `/services/{serviceId}/csv-import/process`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload CSV for manual import
         * @param {string} serviceId 
         * @param {UploadRequest} [uploadRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadCsvImport: async (serviceId: string, uploadRequest?: UploadRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('uploadCsvImport', 'serviceId', serviceId)
            const localVarPath = `/services/{serviceId}/csv-import/upload`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uploadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CSVImportApi - functional programming interface
 * @export
 */
export const CSVImportApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CSVImportApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Process last updated CSV
         * @param {string} serviceId 
         * @param {InlineObject5} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async servicesServiceIdCsvImportProcessPost(serviceId: string, body?: InlineObject5, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicesServiceIdCsvImportProcessPost(serviceId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Upload CSV for manual import
         * @param {string} serviceId 
         * @param {UploadRequest} [uploadRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadCsvImport(serviceId: string, uploadRequest?: UploadRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2008>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadCsvImport(serviceId, uploadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CSVImportApi - factory interface
 * @export
 */
export const CSVImportApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CSVImportApiFp(configuration)
    return {
        /**
         * 
         * @summary Process last updated CSV
         * @param {string} serviceId 
         * @param {InlineObject5} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesServiceIdCsvImportProcessPost(serviceId: string, body?: InlineObject5, options?: any): AxiosPromise<object> {
            return localVarFp.servicesServiceIdCsvImportProcessPost(serviceId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload CSV for manual import
         * @param {string} serviceId 
         * @param {UploadRequest} [uploadRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadCsvImport(serviceId: string, uploadRequest?: UploadRequest, options?: any): AxiosPromise<InlineResponse2008> {
            return localVarFp.uploadCsvImport(serviceId, uploadRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CSVImportApi - object-oriented interface
 * @export
 * @class CSVImportApi
 * @extends {BaseAPI}
 */
export class CSVImportApi extends BaseAPI {
    /**
     * 
     * @summary Process last updated CSV
     * @param {string} serviceId 
     * @param {InlineObject5} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CSVImportApi
     */
    public servicesServiceIdCsvImportProcessPost(serviceId: string, body?: InlineObject5, options?: any) {
        return CSVImportApiFp(this.configuration).servicesServiceIdCsvImportProcessPost(serviceId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload CSV for manual import
     * @param {string} serviceId 
     * @param {UploadRequest} [uploadRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CSVImportApi
     */
    public uploadCsvImport(serviceId: string, uploadRequest?: UploadRequest, options?: any) {
        return CSVImportApiFp(this.configuration).uploadCsvImport(serviceId, uploadRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CalendarEventsApi - axios parameter creator
 * @export
 */
export const CalendarEventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List of all available templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceCalendarTemplates: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/calendar/templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Bulk delete calendar events.  If an error occurs, all changes made by the request will be reverted and an error message is returned with an appropriate HTTP code and more information in the response body.
         * @summary Bulk delete calendar events
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesServiceIdCalendarEventsBulkDeleteDelete: async (serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('servicesServiceIdCalendarEventsBulkDeleteDelete', 'serviceId', serviceId)
            const localVarPath = `/services/{serviceId}/calendar/events/bulk-delete`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Bulk create and edit calendar events. If the event object has **uuid** the event will be updated, otherwise, a new event will be created.  If an error occurs, all changes made by the request will be reverted and an error message is returned with an appropriate HTTP code and more information in the response body.
         * @summary Bulk edit calendar events
         * @param {string} serviceId 
         * @param {InlineObject6} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesServiceIdCalendarEventsBulkUpsertPost: async (serviceId: string, body?: InlineObject6, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('servicesServiceIdCalendarEventsBulkUpsertPost', 'serviceId', serviceId)
            const localVarPath = `/services/{serviceId}/calendar/events/bulk-upsert`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all calendar events
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesServiceIdCalendarEventsGet: async (serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('servicesServiceIdCalendarEventsGet', 'serviceId', serviceId)
            const localVarPath = `/services/{serviceId}/calendar/events`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new calendar event
         * @param {string} serviceId 
         * @param {InlineObject3} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesServiceIdCalendarEventsPost: async (serviceId: string, body?: InlineObject3, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('servicesServiceIdCalendarEventsPost', 'serviceId', serviceId)
            const localVarPath = `/services/{serviceId}/calendar/events`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update calendar event
         * @param {string} serviceId 
         * @param {InlineObject2} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesServiceIdCalendarEventsPut: async (serviceId: string, body?: InlineObject2, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('servicesServiceIdCalendarEventsPut', 'serviceId', serviceId)
            const localVarPath = `/services/{serviceId}/calendar/events`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a Event Type with Template
         * @param {string} serviceId 
         * @param {InlineObject4} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesServiceIdCalendarTemplatesTypePost: async (serviceId: string, body?: InlineObject4, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('servicesServiceIdCalendarTemplatesTypePost', 'serviceId', serviceId)
            const localVarPath = `/services/{serviceId}/calendar/templates/type`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CalendarEventsApi - functional programming interface
 * @export
 */
export const CalendarEventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CalendarEventsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List of all available templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServiceCalendarTemplates(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse2007>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceCalendarTemplates(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Bulk delete calendar events.  If an error occurs, all changes made by the request will be reverted and an error message is returned with an appropriate HTTP code and more information in the response body.
         * @summary Bulk delete calendar events
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async servicesServiceIdCalendarEventsBulkDeleteDelete(serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicesServiceIdCalendarEventsBulkDeleteDelete(serviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Bulk create and edit calendar events. If the event object has **uuid** the event will be updated, otherwise, a new event will be created.  If an error occurs, all changes made by the request will be reverted and an error message is returned with an appropriate HTTP code and more information in the response body.
         * @summary Bulk edit calendar events
         * @param {string} serviceId 
         * @param {InlineObject6} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async servicesServiceIdCalendarEventsBulkUpsertPost(serviceId: string, body?: InlineObject6, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicesServiceIdCalendarEventsBulkUpsertPost(serviceId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all calendar events
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async servicesServiceIdCalendarEventsGet(serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse2006>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicesServiceIdCalendarEventsGet(serviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create new calendar event
         * @param {string} serviceId 
         * @param {InlineObject3} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async servicesServiceIdCalendarEventsPost(serviceId: string, body?: InlineObject3, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicesServiceIdCalendarEventsPost(serviceId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update calendar event
         * @param {string} serviceId 
         * @param {InlineObject2} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async servicesServiceIdCalendarEventsPut(serviceId: string, body?: InlineObject2, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicesServiceIdCalendarEventsPut(serviceId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a Event Type with Template
         * @param {string} serviceId 
         * @param {InlineObject4} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async servicesServiceIdCalendarTemplatesTypePost(serviceId: string, body?: InlineObject4, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicesServiceIdCalendarTemplatesTypePost(serviceId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CalendarEventsApi - factory interface
 * @export
 */
export const CalendarEventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CalendarEventsApiFp(configuration)
    return {
        /**
         * 
         * @summary List of all available templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceCalendarTemplates(options?: any): AxiosPromise<Array<InlineResponse2007>> {
            return localVarFp.getServiceCalendarTemplates(options).then((request) => request(axios, basePath));
        },
        /**
         * Bulk delete calendar events.  If an error occurs, all changes made by the request will be reverted and an error message is returned with an appropriate HTTP code and more information in the response body.
         * @summary Bulk delete calendar events
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesServiceIdCalendarEventsBulkDeleteDelete(serviceId: string, options?: any): AxiosPromise<object> {
            return localVarFp.servicesServiceIdCalendarEventsBulkDeleteDelete(serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Bulk create and edit calendar events. If the event object has **uuid** the event will be updated, otherwise, a new event will be created.  If an error occurs, all changes made by the request will be reverted and an error message is returned with an appropriate HTTP code and more information in the response body.
         * @summary Bulk edit calendar events
         * @param {string} serviceId 
         * @param {InlineObject6} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesServiceIdCalendarEventsBulkUpsertPost(serviceId: string, body?: InlineObject6, options?: any): AxiosPromise<object> {
            return localVarFp.servicesServiceIdCalendarEventsBulkUpsertPost(serviceId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all calendar events
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesServiceIdCalendarEventsGet(serviceId: string, options?: any): AxiosPromise<Array<InlineResponse2006>> {
            return localVarFp.servicesServiceIdCalendarEventsGet(serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create new calendar event
         * @param {string} serviceId 
         * @param {InlineObject3} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesServiceIdCalendarEventsPost(serviceId: string, body?: InlineObject3, options?: any): AxiosPromise<object> {
            return localVarFp.servicesServiceIdCalendarEventsPost(serviceId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update calendar event
         * @param {string} serviceId 
         * @param {InlineObject2} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesServiceIdCalendarEventsPut(serviceId: string, body?: InlineObject2, options?: any): AxiosPromise<object> {
            return localVarFp.servicesServiceIdCalendarEventsPut(serviceId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a Event Type with Template
         * @param {string} serviceId 
         * @param {InlineObject4} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesServiceIdCalendarTemplatesTypePost(serviceId: string, body?: InlineObject4, options?: any): AxiosPromise<object> {
            return localVarFp.servicesServiceIdCalendarTemplatesTypePost(serviceId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CalendarEventsApi - object-oriented interface
 * @export
 * @class CalendarEventsApi
 * @extends {BaseAPI}
 */
export class CalendarEventsApi extends BaseAPI {
    /**
     * 
     * @summary List of all available templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CalendarEventsApi
     */
    public getServiceCalendarTemplates(options?: any) {
        return CalendarEventsApiFp(this.configuration).getServiceCalendarTemplates(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Bulk delete calendar events.  If an error occurs, all changes made by the request will be reverted and an error message is returned with an appropriate HTTP code and more information in the response body.
     * @summary Bulk delete calendar events
     * @param {string} serviceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CalendarEventsApi
     */
    public servicesServiceIdCalendarEventsBulkDeleteDelete(serviceId: string, options?: any) {
        return CalendarEventsApiFp(this.configuration).servicesServiceIdCalendarEventsBulkDeleteDelete(serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Bulk create and edit calendar events. If the event object has **uuid** the event will be updated, otherwise, a new event will be created.  If an error occurs, all changes made by the request will be reverted and an error message is returned with an appropriate HTTP code and more information in the response body.
     * @summary Bulk edit calendar events
     * @param {string} serviceId 
     * @param {InlineObject6} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CalendarEventsApi
     */
    public servicesServiceIdCalendarEventsBulkUpsertPost(serviceId: string, body?: InlineObject6, options?: any) {
        return CalendarEventsApiFp(this.configuration).servicesServiceIdCalendarEventsBulkUpsertPost(serviceId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all calendar events
     * @param {string} serviceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CalendarEventsApi
     */
    public servicesServiceIdCalendarEventsGet(serviceId: string, options?: any) {
        return CalendarEventsApiFp(this.configuration).servicesServiceIdCalendarEventsGet(serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create new calendar event
     * @param {string} serviceId 
     * @param {InlineObject3} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CalendarEventsApi
     */
    public servicesServiceIdCalendarEventsPost(serviceId: string, body?: InlineObject3, options?: any) {
        return CalendarEventsApiFp(this.configuration).servicesServiceIdCalendarEventsPost(serviceId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update calendar event
     * @param {string} serviceId 
     * @param {InlineObject2} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CalendarEventsApi
     */
    public servicesServiceIdCalendarEventsPut(serviceId: string, body?: InlineObject2, options?: any) {
        return CalendarEventsApiFp(this.configuration).servicesServiceIdCalendarEventsPut(serviceId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a Event Type with Template
     * @param {string} serviceId 
     * @param {InlineObject4} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CalendarEventsApi
     */
    public servicesServiceIdCalendarTemplatesTypePost(serviceId: string, body?: InlineObject4, options?: any) {
        return CalendarEventsApiFp(this.configuration).servicesServiceIdCalendarTemplatesTypePost(serviceId, body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ContactFieldsApi - axios parameter creator
 * @export
 */
export const ContactFieldsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create contact field
         * @param {string} serviceId 
         * @param {ContactFieldInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContactField: async (serviceId: string, body?: ContactFieldInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('createContactField', 'serviceId', serviceId)
            const localVarPath = `/services/{serviceId}/contact-fields`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete contact field
         * @param {string} serviceId 
         * @param {string} contactFieldId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContactField: async (serviceId: string, contactFieldId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('deleteContactField', 'serviceId', serviceId)
            // verify required parameter 'contactFieldId' is not null or undefined
            assertParamExists('deleteContactField', 'contactFieldId', contactFieldId)
            const localVarPath = `/services/{serviceId}/contact-fields/{contactFieldId}`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)))
                .replace(`{${"contactFieldId"}}`, encodeURIComponent(String(contactFieldId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get contact field
         * @param {string} serviceId 
         * @param {string} contactFieldId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContactField: async (serviceId: string, contactFieldId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('getContactField', 'serviceId', serviceId)
            // verify required parameter 'contactFieldId' is not null or undefined
            assertParamExists('getContactField', 'contactFieldId', contactFieldId)
            const localVarPath = `/services/{serviceId}/contact-fields/{contactFieldId}`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)))
                .replace(`{${"contactFieldId"}}`, encodeURIComponent(String(contactFieldId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List contact fields
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContactFields: async (serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('listContactFields', 'serviceId', serviceId)
            const localVarPath = `/services/{serviceId}/contact-fields`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Organization Contact Fields
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsOrganizationIdContactFieldsGet: async (organizationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('organizationsOrganizationIdContactFieldsGet', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organizationId}/contact-fields`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update contact field
         * @param {string} serviceId 
         * @param {string} contactFieldId 
         * @param {ContactFieldInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContactField: async (serviceId: string, contactFieldId: string, body?: ContactFieldInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('updateContactField', 'serviceId', serviceId)
            // verify required parameter 'contactFieldId' is not null or undefined
            assertParamExists('updateContactField', 'contactFieldId', contactFieldId)
            const localVarPath = `/services/{serviceId}/contact-fields/{contactFieldId}`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)))
                .replace(`{${"contactFieldId"}}`, encodeURIComponent(String(contactFieldId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContactFieldsApi - functional programming interface
 * @export
 */
export const ContactFieldsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContactFieldsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create contact field
         * @param {string} serviceId 
         * @param {ContactFieldInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContactField(serviceId: string, body?: ContactFieldInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContactField(serviceId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete contact field
         * @param {string} serviceId 
         * @param {string} contactFieldId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteContactField(serviceId: string, contactFieldId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteContactField(serviceId, contactFieldId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get contact field
         * @param {string} serviceId 
         * @param {string} contactFieldId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContactField(serviceId: string, contactFieldId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactField>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContactField(serviceId, contactFieldId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List contact fields
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContactFields(serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ContactField>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listContactFields(serviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Organization Contact Fields
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationsOrganizationIdContactFieldsGet(organizationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationsOrganizationIdContactFieldsGet(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update contact field
         * @param {string} serviceId 
         * @param {string} contactFieldId 
         * @param {ContactFieldInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateContactField(serviceId: string, contactFieldId: string, body?: ContactFieldInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateContactField(serviceId, contactFieldId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContactFieldsApi - factory interface
 * @export
 */
export const ContactFieldsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContactFieldsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create contact field
         * @param {string} serviceId 
         * @param {ContactFieldInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContactField(serviceId: string, body?: ContactFieldInput, options?: any): AxiosPromise<void> {
            return localVarFp.createContactField(serviceId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete contact field
         * @param {string} serviceId 
         * @param {string} contactFieldId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContactField(serviceId: string, contactFieldId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteContactField(serviceId, contactFieldId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get contact field
         * @param {string} serviceId 
         * @param {string} contactFieldId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContactField(serviceId: string, contactFieldId: string, options?: any): AxiosPromise<ContactField> {
            return localVarFp.getContactField(serviceId, contactFieldId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List contact fields
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContactFields(serviceId: string, options?: any): AxiosPromise<Array<ContactField>> {
            return localVarFp.listContactFields(serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Organization Contact Fields
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsOrganizationIdContactFieldsGet(organizationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.organizationsOrganizationIdContactFieldsGet(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update contact field
         * @param {string} serviceId 
         * @param {string} contactFieldId 
         * @param {ContactFieldInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContactField(serviceId: string, contactFieldId: string, body?: ContactFieldInput, options?: any): AxiosPromise<void> {
            return localVarFp.updateContactField(serviceId, contactFieldId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContactFieldsApi - object-oriented interface
 * @export
 * @class ContactFieldsApi
 * @extends {BaseAPI}
 */
export class ContactFieldsApi extends BaseAPI {
    /**
     * 
     * @summary Create contact field
     * @param {string} serviceId 
     * @param {ContactFieldInput} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactFieldsApi
     */
    public createContactField(serviceId: string, body?: ContactFieldInput, options?: any) {
        return ContactFieldsApiFp(this.configuration).createContactField(serviceId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete contact field
     * @param {string} serviceId 
     * @param {string} contactFieldId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactFieldsApi
     */
    public deleteContactField(serviceId: string, contactFieldId: string, options?: any) {
        return ContactFieldsApiFp(this.configuration).deleteContactField(serviceId, contactFieldId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get contact field
     * @param {string} serviceId 
     * @param {string} contactFieldId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactFieldsApi
     */
    public getContactField(serviceId: string, contactFieldId: string, options?: any) {
        return ContactFieldsApiFp(this.configuration).getContactField(serviceId, contactFieldId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List contact fields
     * @param {string} serviceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactFieldsApi
     */
    public listContactFields(serviceId: string, options?: any) {
        return ContactFieldsApiFp(this.configuration).listContactFields(serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Organization Contact Fields
     * @param {string} organizationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactFieldsApi
     */
    public organizationsOrganizationIdContactFieldsGet(organizationId: string, options?: any) {
        return ContactFieldsApiFp(this.configuration).organizationsOrganizationIdContactFieldsGet(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update contact field
     * @param {string} serviceId 
     * @param {string} contactFieldId 
     * @param {ContactFieldInput} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactFieldsApi
     */
    public updateContactField(serviceId: string, contactFieldId: string, body?: ContactFieldInput, options?: any) {
        return ContactFieldsApiFp(this.configuration).updateContactField(serviceId, contactFieldId, body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ContactImportLogApi - axios parameter creator
 * @export
 */
export const ContactImportLogApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a list of entries from the Contact Import Log
         * @param {string} serviceId 
         * @param {string} rangeStart 
         * @param {string} rangeEnd 
         * @param {string} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContactImportLog: async (serviceId: string, rangeStart: string, rangeEnd: string, query?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('listContactImportLog', 'serviceId', serviceId)
            // verify required parameter 'rangeStart' is not null or undefined
            assertParamExists('listContactImportLog', 'rangeStart', rangeStart)
            // verify required parameter 'rangeEnd' is not null or undefined
            assertParamExists('listContactImportLog', 'rangeEnd', rangeEnd)
            const localVarPath = `/services/{serviceId}/contact-log`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (rangeStart !== undefined) {
                localVarQueryParameter['range[start]'] = (rangeStart as any instanceof Date) ?
                    (rangeStart as any).toISOString() :
                    rangeStart;
            }

            if (rangeEnd !== undefined) {
                localVarQueryParameter['range[end]'] = (rangeEnd as any instanceof Date) ?
                    (rangeEnd as any).toISOString() :
                    rangeEnd;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContactImportLogApi - functional programming interface
 * @export
 */
export const ContactImportLogApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContactImportLogApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a list of entries from the Contact Import Log
         * @param {string} serviceId 
         * @param {string} rangeStart 
         * @param {string} rangeEnd 
         * @param {string} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContactImportLog(serviceId: string, rangeStart: string, rangeEnd: string, query?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ContactLog>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listContactImportLog(serviceId, rangeStart, rangeEnd, query, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContactImportLogApi - factory interface
 * @export
 */
export const ContactImportLogApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContactImportLogApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a list of entries from the Contact Import Log
         * @param {string} serviceId 
         * @param {string} rangeStart 
         * @param {string} rangeEnd 
         * @param {string} [query] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContactImportLog(serviceId: string, rangeStart: string, rangeEnd: string, query?: string, options?: any): AxiosPromise<Array<ContactLog>> {
            return localVarFp.listContactImportLog(serviceId, rangeStart, rangeEnd, query, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContactImportLogApi - object-oriented interface
 * @export
 * @class ContactImportLogApi
 * @extends {BaseAPI}
 */
export class ContactImportLogApi extends BaseAPI {
    /**
     * 
     * @summary Get a list of entries from the Contact Import Log
     * @param {string} serviceId 
     * @param {string} rangeStart 
     * @param {string} rangeEnd 
     * @param {string} [query] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactImportLogApi
     */
    public listContactImportLog(serviceId: string, rangeStart: string, rangeEnd: string, query?: string, options?: any) {
        return ContactImportLogApiFp(this.configuration).listContactImportLog(serviceId, rangeStart, rangeEnd, query, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ContactsApi - axios parameter creator
 * @export
 */
export const ContactsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Contact
         * @param {string} serviceId 
         * @param {RecordRequest} [body] One of the following is required:  * firstName * lastName * externalId * at least one channel object * at least one contactFields object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContact: async (serviceId: string, body?: RecordRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('createContact', 'serviceId', serviceId)
            const localVarPath = `/services/{serviceId}/contacts`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Contact
         * @param {string} serviceId 
         * @param {string} contactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContact: async (serviceId: string, contactId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('deleteContact', 'serviceId', serviceId)
            // verify required parameter 'contactId' is not null or undefined
            assertParamExists('deleteContact', 'contactId', contactId)
            const localVarPath = `/services/{serviceId}/contacts/{contactId}`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)))
                .replace(`{${"contactId"}}`, encodeURIComponent(String(contactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Contact by customer-defined ID
         * @param {string} serviceId 
         * @param {string} externalContactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContactByExternal: async (serviceId: string, externalContactId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('deleteContactByExternal', 'serviceId', serviceId)
            // verify required parameter 'externalContactId' is not null or undefined
            assertParamExists('deleteContactByExternal', 'externalContactId', externalContactId)
            const localVarPath = `/services/{serviceId}/contacts/ref/{externalContactId}`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)))
                .replace(`{${"externalContactId"}}`, encodeURIComponent(String(externalContactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Contact
         * @param {string} serviceId 
         * @param {string} contactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContact: async (serviceId: string, contactId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('getContact', 'serviceId', serviceId)
            // verify required parameter 'contactId' is not null or undefined
            assertParamExists('getContact', 'contactId', contactId)
            const localVarPath = `/services/{serviceId}/contacts/{contactId}`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)))
                .replace(`{${"contactId"}}`, encodeURIComponent(String(contactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Contact by customer-defined ID
         * @param {string} serviceId 
         * @param {string} externalContactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContactByExternal: async (serviceId: string, externalContactId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('getContactByExternal', 'serviceId', serviceId)
            // verify required parameter 'externalContactId' is not null or undefined
            assertParamExists('getContactByExternal', 'externalContactId', externalContactId)
            const localVarPath = `/services/{serviceId}/contacts/ref/{externalContactId}`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)))
                .replace(`{${"externalContactId"}}`, encodeURIComponent(String(externalContactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Contacts
         * @param {string} serviceId 
         * @param {'read' | 'unread'} [mentions] Filter contacts only with read or unread mentions in feeds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContacts: async (serviceId: string, mentions?: 'read' | 'unread', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('listContacts', 'serviceId', serviceId)
            const localVarPath = `/services/{serviceId}/contacts`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (mentions !== undefined) {
                localVarQueryParameter['mentions'] = mentions;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Export contacts
         * @param {string} serviceId 
         * @param {InlineObject9} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesServiceIdContactsExportGet: async (serviceId: string, body?: InlineObject9, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('servicesServiceIdContactsExportGet', 'serviceId', serviceId)
            const localVarPath = `/services/{serviceId}/contacts/export`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Contact
         * @param {string} serviceId 
         * @param {string} contactId 
         * @param {RecordRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContact: async (serviceId: string, contactId: string, body?: RecordRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('updateContact', 'serviceId', serviceId)
            // verify required parameter 'contactId' is not null or undefined
            assertParamExists('updateContact', 'contactId', contactId)
            const localVarPath = `/services/{serviceId}/contacts/{contactId}`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)))
                .replace(`{${"contactId"}}`, encodeURIComponent(String(contactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Contact by customer-defined ID
         * @param {string} serviceId 
         * @param {string} externalContactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContactByExternal: async (serviceId: string, externalContactId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('updateContactByExternal', 'serviceId', serviceId)
            // verify required parameter 'externalContactId' is not null or undefined
            assertParamExists('updateContactByExternal', 'externalContactId', externalContactId)
            const localVarPath = `/services/{serviceId}/contacts/ref/{externalContactId}`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)))
                .replace(`{${"externalContactId"}}`, encodeURIComponent(String(externalContactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContactsApi - functional programming interface
 * @export
 */
export const ContactsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContactsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Contact
         * @param {string} serviceId 
         * @param {RecordRequest} [body] One of the following is required:  * firstName * lastName * externalId * at least one channel object * at least one contactFields object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContact(serviceId: string, body?: RecordRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContact(serviceId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Contact
         * @param {string} serviceId 
         * @param {string} contactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteContact(serviceId: string, contactId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteContact(serviceId, contactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Contact by customer-defined ID
         * @param {string} serviceId 
         * @param {string} externalContactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteContactByExternal(serviceId: string, externalContactId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteContactByExternal(serviceId, externalContactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Contact
         * @param {string} serviceId 
         * @param {string} contactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContact(serviceId: string, contactId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContact(serviceId, contactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Contact by customer-defined ID
         * @param {string} serviceId 
         * @param {string} externalContactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContactByExternal(serviceId: string, externalContactId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContactByExternal(serviceId, externalContactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Contacts
         * @param {string} serviceId 
         * @param {'read' | 'unread'} [mentions] Filter contacts only with read or unread mentions in feeds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContacts(serviceId: string, mentions?: 'read' | 'unread', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listContacts(serviceId, mentions, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Export contacts
         * @param {string} serviceId 
         * @param {InlineObject9} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async servicesServiceIdContactsExportGet(serviceId: string, body?: InlineObject9, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicesServiceIdContactsExportGet(serviceId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update Contact
         * @param {string} serviceId 
         * @param {string} contactId 
         * @param {RecordRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateContact(serviceId: string, contactId: string, body?: RecordRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateContact(serviceId, contactId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update Contact by customer-defined ID
         * @param {string} serviceId 
         * @param {string} externalContactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateContactByExternal(serviceId: string, externalContactId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateContactByExternal(serviceId, externalContactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContactsApi - factory interface
 * @export
 */
export const ContactsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContactsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Contact
         * @param {string} serviceId 
         * @param {RecordRequest} [body] One of the following is required:  * firstName * lastName * externalId * at least one channel object * at least one contactFields object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContact(serviceId: string, body?: RecordRequest, options?: any): AxiosPromise<void> {
            return localVarFp.createContact(serviceId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Contact
         * @param {string} serviceId 
         * @param {string} contactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContact(serviceId: string, contactId: string, options?: any): AxiosPromise<object> {
            return localVarFp.deleteContact(serviceId, contactId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Contact by customer-defined ID
         * @param {string} serviceId 
         * @param {string} externalContactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContactByExternal(serviceId: string, externalContactId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteContactByExternal(serviceId, externalContactId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Contact
         * @param {string} serviceId 
         * @param {string} contactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContact(serviceId: string, contactId: string, options?: any): AxiosPromise<InlineResponse2001> {
            return localVarFp.getContact(serviceId, contactId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Contact by customer-defined ID
         * @param {string} serviceId 
         * @param {string} externalContactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContactByExternal(serviceId: string, externalContactId: string, options?: any): AxiosPromise<void> {
            return localVarFp.getContactByExternal(serviceId, externalContactId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Contacts
         * @param {string} serviceId 
         * @param {'read' | 'unread'} [mentions] Filter contacts only with read or unread mentions in feeds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContacts(serviceId: string, mentions?: 'read' | 'unread', options?: any): AxiosPromise<Array<object>> {
            return localVarFp.listContacts(serviceId, mentions, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Export contacts
         * @param {string} serviceId 
         * @param {InlineObject9} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesServiceIdContactsExportGet(serviceId: string, body?: InlineObject9, options?: any): AxiosPromise<object> {
            return localVarFp.servicesServiceIdContactsExportGet(serviceId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Contact
         * @param {string} serviceId 
         * @param {string} contactId 
         * @param {RecordRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContact(serviceId: string, contactId: string, body?: RecordRequest, options?: any): AxiosPromise<object> {
            return localVarFp.updateContact(serviceId, contactId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Contact by customer-defined ID
         * @param {string} serviceId 
         * @param {string} externalContactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContactByExternal(serviceId: string, externalContactId: string, options?: any): AxiosPromise<void> {
            return localVarFp.updateContactByExternal(serviceId, externalContactId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContactsApi - object-oriented interface
 * @export
 * @class ContactsApi
 * @extends {BaseAPI}
 */
export class ContactsApi extends BaseAPI {
    /**
     * 
     * @summary Create Contact
     * @param {string} serviceId 
     * @param {RecordRequest} [body] One of the following is required:  * firstName * lastName * externalId * at least one channel object * at least one contactFields object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public createContact(serviceId: string, body?: RecordRequest, options?: any) {
        return ContactsApiFp(this.configuration).createContact(serviceId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Contact
     * @param {string} serviceId 
     * @param {string} contactId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public deleteContact(serviceId: string, contactId: string, options?: any) {
        return ContactsApiFp(this.configuration).deleteContact(serviceId, contactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Contact by customer-defined ID
     * @param {string} serviceId 
     * @param {string} externalContactId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public deleteContactByExternal(serviceId: string, externalContactId: string, options?: any) {
        return ContactsApiFp(this.configuration).deleteContactByExternal(serviceId, externalContactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Contact
     * @param {string} serviceId 
     * @param {string} contactId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public getContact(serviceId: string, contactId: string, options?: any) {
        return ContactsApiFp(this.configuration).getContact(serviceId, contactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Contact by customer-defined ID
     * @param {string} serviceId 
     * @param {string} externalContactId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public getContactByExternal(serviceId: string, externalContactId: string, options?: any) {
        return ContactsApiFp(this.configuration).getContactByExternal(serviceId, externalContactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Contacts
     * @param {string} serviceId 
     * @param {'read' | 'unread'} [mentions] Filter contacts only with read or unread mentions in feeds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public listContacts(serviceId: string, mentions?: 'read' | 'unread', options?: any) {
        return ContactsApiFp(this.configuration).listContacts(serviceId, mentions, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Export contacts
     * @param {string} serviceId 
     * @param {InlineObject9} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public servicesServiceIdContactsExportGet(serviceId: string, body?: InlineObject9, options?: any) {
        return ContactsApiFp(this.configuration).servicesServiceIdContactsExportGet(serviceId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Contact
     * @param {string} serviceId 
     * @param {string} contactId 
     * @param {RecordRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public updateContact(serviceId: string, contactId: string, body?: RecordRequest, options?: any) {
        return ContactsApiFp(this.configuration).updateContact(serviceId, contactId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Contact by customer-defined ID
     * @param {string} serviceId 
     * @param {string} externalContactId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public updateContactByExternal(serviceId: string, externalContactId: string, options?: any) {
        return ContactsApiFp(this.configuration).updateContactByExternal(serviceId, externalContactId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create User
         * @param {string} serviceId 
         * @param {UserCreateInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (serviceId: string, body?: UserCreateInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('createUser', 'serviceId', serviceId)
            const localVarPath = `/services/{serviceId}/users`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Look up an IDP by domain code
         * @param {string} [domainCode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        samlIdpsLookupGet: async (domainCode?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/saml/idps/lookup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (domainCode !== undefined) {
                localVarQueryParameter['domainCode'] = domainCode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the field mapping for an integration
         * @param {string} serviceId 
         * @param {string} integration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesServiceIdIntegrationsIntegrationFieldMappingGet: async (serviceId: string, integration: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('servicesServiceIdIntegrationsIntegrationFieldMappingGet', 'serviceId', serviceId)
            // verify required parameter 'integration' is not null or undefined
            assertParamExists('servicesServiceIdIntegrationsIntegrationFieldMappingGet', 'integration', integration)
            const localVarPath = `/services/{serviceId}/integrations/{integration}/field-mapping`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)))
                .replace(`{${"integration"}}`, encodeURIComponent(String(integration)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Segment
         * @param {string} serviceId 
         * @param {string} segmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesServiceIdSegmentsSegmentIdDelete: async (serviceId: string, segmentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('servicesServiceIdSegmentsSegmentIdDelete', 'serviceId', serviceId)
            // verify required parameter 'segmentId' is not null or undefined
            assertParamExists('servicesServiceIdSegmentsSegmentIdDelete', 'segmentId', segmentId)
            const localVarPath = `/services/{serviceId}/segments/{segmentId}`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)))
                .replace(`{${"segmentId"}}`, encodeURIComponent(String(segmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Receive a contact id, external id or phone number to identify a contact and start the workflow specified in the url.
         * @summary Start a new workflow for the specified contact
         * @param {number} serviceId 
         * @param {number} zingId 
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesServiceIdZingsZingIdStartPost: async (serviceId: number, zingId: number, body?: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('servicesServiceIdZingsZingIdStartPost', 'serviceId', serviceId)
            // verify required parameter 'zingId' is not null or undefined
            assertParamExists('servicesServiceIdZingsZingIdStartPost', 'zingId', zingId)
            const localVarPath = `/services/{serviceId}/zings/{zingId}/start`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)))
                .replace(`{${"zingId"}}`, encodeURIComponent(String(zingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update notification preferences
         * @param {string} userId 
         * @param {InlineObject10} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserNotificationPerferences: async (userId: string, body?: InlineObject10, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateUserNotificationPerferences', 'userId', userId)
            const localVarPath = `/notification/{userId}/preferences`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create User
         * @param {string} serviceId 
         * @param {UserCreateInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(serviceId: string, body?: UserCreateInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(serviceId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Look up an IDP by domain code
         * @param {string} [domainCode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async samlIdpsLookupGet(domainCode?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2005>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.samlIdpsLookupGet(domainCode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the field mapping for an integration
         * @param {string} serviceId 
         * @param {string} integration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async servicesServiceIdIntegrationsIntegrationFieldMappingGet(serviceId: string, integration: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicesServiceIdIntegrationsIntegrationFieldMappingGet(serviceId, integration, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Segment
         * @param {string} serviceId 
         * @param {string} segmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async servicesServiceIdSegmentsSegmentIdDelete(serviceId: string, segmentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicesServiceIdSegmentsSegmentIdDelete(serviceId, segmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Receive a contact id, external id or phone number to identify a contact and start the workflow specified in the url.
         * @summary Start a new workflow for the specified contact
         * @param {number} serviceId 
         * @param {number} zingId 
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async servicesServiceIdZingsZingIdStartPost(serviceId: number, zingId: number, body?: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicesServiceIdZingsZingIdStartPost(serviceId, zingId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update notification preferences
         * @param {string} userId 
         * @param {InlineObject10} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserNotificationPerferences(userId: string, body?: InlineObject10, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20012>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserNotificationPerferences(userId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary Create User
         * @param {string} serviceId 
         * @param {UserCreateInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(serviceId: string, body?: UserCreateInput, options?: any): AxiosPromise<object> {
            return localVarFp.createUser(serviceId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Look up an IDP by domain code
         * @param {string} [domainCode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        samlIdpsLookupGet(domainCode?: string, options?: any): AxiosPromise<InlineResponse2005> {
            return localVarFp.samlIdpsLookupGet(domainCode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the field mapping for an integration
         * @param {string} serviceId 
         * @param {string} integration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesServiceIdIntegrationsIntegrationFieldMappingGet(serviceId: string, integration: string, options?: any): AxiosPromise<object> {
            return localVarFp.servicesServiceIdIntegrationsIntegrationFieldMappingGet(serviceId, integration, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Segment
         * @param {string} serviceId 
         * @param {string} segmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesServiceIdSegmentsSegmentIdDelete(serviceId: string, segmentId: string, options?: any): AxiosPromise<object> {
            return localVarFp.servicesServiceIdSegmentsSegmentIdDelete(serviceId, segmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Receive a contact id, external id or phone number to identify a contact and start the workflow specified in the url.
         * @summary Start a new workflow for the specified contact
         * @param {number} serviceId 
         * @param {number} zingId 
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesServiceIdZingsZingIdStartPost(serviceId: number, zingId: number, body?: object, options?: any): AxiosPromise<object> {
            return localVarFp.servicesServiceIdZingsZingIdStartPost(serviceId, zingId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update notification preferences
         * @param {string} userId 
         * @param {InlineObject10} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserNotificationPerferences(userId: string, body?: InlineObject10, options?: any): AxiosPromise<InlineResponse20012> {
            return localVarFp.updateUserNotificationPerferences(userId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Create User
     * @param {string} serviceId 
     * @param {UserCreateInput} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createUser(serviceId: string, body?: UserCreateInput, options?: any) {
        return DefaultApiFp(this.configuration).createUser(serviceId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Look up an IDP by domain code
     * @param {string} [domainCode] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public samlIdpsLookupGet(domainCode?: string, options?: any) {
        return DefaultApiFp(this.configuration).samlIdpsLookupGet(domainCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the field mapping for an integration
     * @param {string} serviceId 
     * @param {string} integration 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public servicesServiceIdIntegrationsIntegrationFieldMappingGet(serviceId: string, integration: string, options?: any) {
        return DefaultApiFp(this.configuration).servicesServiceIdIntegrationsIntegrationFieldMappingGet(serviceId, integration, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Segment
     * @param {string} serviceId 
     * @param {string} segmentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public servicesServiceIdSegmentsSegmentIdDelete(serviceId: string, segmentId: string, options?: any) {
        return DefaultApiFp(this.configuration).servicesServiceIdSegmentsSegmentIdDelete(serviceId, segmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Receive a contact id, external id or phone number to identify a contact and start the workflow specified in the url.
     * @summary Start a new workflow for the specified contact
     * @param {number} serviceId 
     * @param {number} zingId 
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public servicesServiceIdZingsZingIdStartPost(serviceId: number, zingId: number, body?: object, options?: any) {
        return DefaultApiFp(this.configuration).servicesServiceIdZingsZingIdStartPost(serviceId, zingId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update notification preferences
     * @param {string} userId 
     * @param {InlineObject10} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateUserNotificationPerferences(userId: string, body?: InlineObject10, options?: any) {
        return DefaultApiFp(this.configuration).updateUserNotificationPerferences(userId, body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FeedsApi - axios parameter creator
 * @export
 */
export const FeedsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add an internal note to a Feed. Mentions can be added with the following tags: - If you want to mention a User: {u@xxx-xxx-xxx}  - If you want to mention a whole Team: {t@xxx-xxx-xxx}  Where the \"xxx-xxx-xxx\" is the user or team\'s UUID.  For example: ``` {   \"body\": \"We need help here! {u@646349de-3d3f-4895-9eec-c3c85b9b16f5} {t@85c0a712-c618-46f8-b1e3-a20bdc0feeb3}\" } ```
         * @summary Add an internal note to a Feed
         * @param {string} serviceId 
         * @param {string} feedId Feed\&#39;s UUID
         * @param {InlineObject8} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesServiceIdFeedsFeedIdNotesPost: async (serviceId: string, feedId: string, body?: InlineObject8, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('servicesServiceIdFeedsFeedIdNotesPost', 'serviceId', serviceId)
            // verify required parameter 'feedId' is not null or undefined
            assertParamExists('servicesServiceIdFeedsFeedIdNotesPost', 'feedId', feedId)
            const localVarPath = `/services/{serviceId}/feeds/{feedId}/notes`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)))
                .replace(`{${"feedId"}}`, encodeURIComponent(String(feedId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FeedsApi - functional programming interface
 * @export
 */
export const FeedsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FeedsApiAxiosParamCreator(configuration)
    return {
        /**
         * Add an internal note to a Feed. Mentions can be added with the following tags: - If you want to mention a User: {u@xxx-xxx-xxx}  - If you want to mention a whole Team: {t@xxx-xxx-xxx}  Where the \"xxx-xxx-xxx\" is the user or team\'s UUID.  For example: ``` {   \"body\": \"We need help here! {u@646349de-3d3f-4895-9eec-c3c85b9b16f5} {t@85c0a712-c618-46f8-b1e3-a20bdc0feeb3}\" } ```
         * @summary Add an internal note to a Feed
         * @param {string} serviceId 
         * @param {string} feedId Feed\&#39;s UUID
         * @param {InlineObject8} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async servicesServiceIdFeedsFeedIdNotesPost(serviceId: string, feedId: string, body?: InlineObject8, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicesServiceIdFeedsFeedIdNotesPost(serviceId, feedId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FeedsApi - factory interface
 * @export
 */
export const FeedsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FeedsApiFp(configuration)
    return {
        /**
         * Add an internal note to a Feed. Mentions can be added with the following tags: - If you want to mention a User: {u@xxx-xxx-xxx}  - If you want to mention a whole Team: {t@xxx-xxx-xxx}  Where the \"xxx-xxx-xxx\" is the user or team\'s UUID.  For example: ``` {   \"body\": \"We need help here! {u@646349de-3d3f-4895-9eec-c3c85b9b16f5} {t@85c0a712-c618-46f8-b1e3-a20bdc0feeb3}\" } ```
         * @summary Add an internal note to a Feed
         * @param {string} serviceId 
         * @param {string} feedId Feed\&#39;s UUID
         * @param {InlineObject8} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesServiceIdFeedsFeedIdNotesPost(serviceId: string, feedId: string, body?: InlineObject8, options?: any): AxiosPromise<object> {
            return localVarFp.servicesServiceIdFeedsFeedIdNotesPost(serviceId, feedId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FeedsApi - object-oriented interface
 * @export
 * @class FeedsApi
 * @extends {BaseAPI}
 */
export class FeedsApi extends BaseAPI {
    /**
     * Add an internal note to a Feed. Mentions can be added with the following tags: - If you want to mention a User: {u@xxx-xxx-xxx}  - If you want to mention a whole Team: {t@xxx-xxx-xxx}  Where the \"xxx-xxx-xxx\" is the user or team\'s UUID.  For example: ``` {   \"body\": \"We need help here! {u@646349de-3d3f-4895-9eec-c3c85b9b16f5} {t@85c0a712-c618-46f8-b1e3-a20bdc0feeb3}\" } ```
     * @summary Add an internal note to a Feed
     * @param {string} serviceId 
     * @param {string} feedId Feed\&#39;s UUID
     * @param {InlineObject8} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedsApi
     */
    public servicesServiceIdFeedsFeedIdNotesPost(serviceId: string, feedId: string, body?: InlineObject8, options?: any) {
        return FeedsApiFp(this.configuration).servicesServiceIdFeedsFeedIdNotesPost(serviceId, feedId, body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * HotSOSApi - axios parameter creator
 * @export
 */
export const HotSOSApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Test HotSOS contact integration
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hotsosContactTest: async (serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('hotsosContactTest', 'serviceId', serviceId)
            const localVarPath = `/services/{serviceId}/hotsos/test-reservations`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HotSOSApi - functional programming interface
 * @export
 */
export const HotSOSApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HotSOSApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Test HotSOS contact integration
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hotsosContactTest(serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse20011>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hotsosContactTest(serviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HotSOSApi - factory interface
 * @export
 */
export const HotSOSApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HotSOSApiFp(configuration)
    return {
        /**
         * 
         * @summary Test HotSOS contact integration
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hotsosContactTest(serviceId: string, options?: any): AxiosPromise<Array<InlineResponse20011>> {
            return localVarFp.hotsosContactTest(serviceId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HotSOSApi - object-oriented interface
 * @export
 * @class HotSOSApi
 * @extends {BaseAPI}
 */
export class HotSOSApi extends BaseAPI {
    /**
     * 
     * @summary Test HotSOS contact integration
     * @param {string} serviceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HotSOSApi
     */
    public hotsosContactTest(serviceId: string, options?: any) {
        return HotSOSApiFp(this.configuration).hotsosContactTest(serviceId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IntegrationsApi - axios parameter creator
 * @export
 */
export const IntegrationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a field mapping for an integration
         * @param {string} serviceId 
         * @param {string} integration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFieldMapping: async (serviceId: string, integration: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('deleteFieldMapping', 'serviceId', serviceId)
            // verify required parameter 'integration' is not null or undefined
            assertParamExists('deleteFieldMapping', 'integration', integration)
            const localVarPath = `/services/{serviceId}/integrations/{integration}/field-mapping`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)))
                .replace(`{${"integration"}}`, encodeURIComponent(String(integration)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Disables an integration, deletes all integration config values, removes an integration-related auth tokens
         * @summary Disable an integration
         * @param {string} serviceId 
         * @param {string} integration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableIntegration: async (serviceId: string, integration: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('disableIntegration', 'serviceId', serviceId)
            // verify required parameter 'integration' is not null or undefined
            assertParamExists('disableIntegration', 'integration', integration)
            const localVarPath = `/services/{serviceId}/integrations/{integration}`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)))
                .replace(`{${"integration"}}`, encodeURIComponent(String(integration)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Enable an integration for a service
         * @param {string} serviceId 
         * @param {string} integration 
         * @param {InlineObject1} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableIntegration: async (serviceId: string, integration: string, body?: InlineObject1, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('enableIntegration', 'serviceId', serviceId)
            // verify required parameter 'integration' is not null or undefined
            assertParamExists('enableIntegration', 'integration', integration)
            const localVarPath = `/services/{serviceId}/integrations/{integration}`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)))
                .replace(`{${"integration"}}`, encodeURIComponent(String(integration)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of all integrations for a service
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegration: async (serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('getIntegration', 'serviceId', serviceId)
            const localVarPath = `/services/{serviceId}/integrations`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Generate an activation link for MindBody
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMindbodyActivationLink: async (serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('getMindbodyActivationLink', 'serviceId', serviceId)
            const localVarPath = `/services/{serviceId}/integrations/mindbody/activation-link`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single integration
         * @param {string} serviceId 
         * @param {string} integration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesServiceIdIntegrationsIntegrationGet: async (serviceId: string, integration: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('servicesServiceIdIntegrationsIntegrationGet', 'serviceId', serviceId)
            // verify required parameter 'integration' is not null or undefined
            assertParamExists('servicesServiceIdIntegrationsIntegrationGet', 'integration', integration)
            const localVarPath = `/services/{serviceId}/integrations/{integration}`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)))
                .replace(`{${"integration"}}`, encodeURIComponent(String(integration)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an integration
         * @param {string} serviceId 
         * @param {string} integration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesServiceIdIntegrationsIntegrationPut: async (serviceId: string, integration: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('servicesServiceIdIntegrationsIntegrationPut', 'serviceId', serviceId)
            // verify required parameter 'integration' is not null or undefined
            assertParamExists('servicesServiceIdIntegrationsIntegrationPut', 'integration', integration)
            const localVarPath = `/services/{serviceId}/integrations/{integration}`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)))
                .replace(`{${"integration"}}`, encodeURIComponent(String(integration)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create or update a field mapping for an integration
         * @param {string} serviceId 
         * @param {string} integration 
         * @param {IntegrationFieldMappingInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFieldMapping: async (serviceId: string, integration: string, body?: IntegrationFieldMappingInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('updateFieldMapping', 'serviceId', serviceId)
            // verify required parameter 'integration' is not null or undefined
            assertParamExists('updateFieldMapping', 'integration', integration)
            const localVarPath = `/services/{serviceId}/integrations/{integration}/field-mapping`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)))
                .replace(`{${"integration"}}`, encodeURIComponent(String(integration)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IntegrationsApi - functional programming interface
 * @export
 */
export const IntegrationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IntegrationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete a field mapping for an integration
         * @param {string} serviceId 
         * @param {string} integration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFieldMapping(serviceId: string, integration: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFieldMapping(serviceId, integration, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Disables an integration, deletes all integration config values, removes an integration-related auth tokens
         * @summary Disable an integration
         * @param {string} serviceId 
         * @param {string} integration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disableIntegration(serviceId: string, integration: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disableIntegration(serviceId, integration, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Enable an integration for a service
         * @param {string} serviceId 
         * @param {string} integration 
         * @param {InlineObject1} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enableIntegration(serviceId: string, integration: string, body?: InlineObject1, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enableIntegration(serviceId, integration, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a list of all integrations for a service
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIntegration(serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse2003>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIntegration(serviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Generate an activation link for MindBody
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMindbodyActivationLink(serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMindbodyActivationLink(serviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a single integration
         * @param {string} serviceId 
         * @param {string} integration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async servicesServiceIdIntegrationsIntegrationGet(serviceId: string, integration: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Integration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicesServiceIdIntegrationsIntegrationGet(serviceId, integration, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an integration
         * @param {string} serviceId 
         * @param {string} integration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async servicesServiceIdIntegrationsIntegrationPut(serviceId: string, integration: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicesServiceIdIntegrationsIntegrationPut(serviceId, integration, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create or update a field mapping for an integration
         * @param {string} serviceId 
         * @param {string} integration 
         * @param {IntegrationFieldMappingInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFieldMapping(serviceId: string, integration: string, body?: IntegrationFieldMappingInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFieldMapping(serviceId, integration, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IntegrationsApi - factory interface
 * @export
 */
export const IntegrationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IntegrationsApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete a field mapping for an integration
         * @param {string} serviceId 
         * @param {string} integration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFieldMapping(serviceId: string, integration: string, options?: any): AxiosPromise<object> {
            return localVarFp.deleteFieldMapping(serviceId, integration, options).then((request) => request(axios, basePath));
        },
        /**
         * Disables an integration, deletes all integration config values, removes an integration-related auth tokens
         * @summary Disable an integration
         * @param {string} serviceId 
         * @param {string} integration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableIntegration(serviceId: string, integration: string, options?: any): AxiosPromise<object> {
            return localVarFp.disableIntegration(serviceId, integration, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Enable an integration for a service
         * @param {string} serviceId 
         * @param {string} integration 
         * @param {InlineObject1} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableIntegration(serviceId: string, integration: string, body?: InlineObject1, options?: any): AxiosPromise<object> {
            return localVarFp.enableIntegration(serviceId, integration, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of all integrations for a service
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegration(serviceId: string, options?: any): AxiosPromise<Array<InlineResponse2003>> {
            return localVarFp.getIntegration(serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Generate an activation link for MindBody
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMindbodyActivationLink(serviceId: string, options?: any): AxiosPromise<InlineResponse2004> {
            return localVarFp.getMindbodyActivationLink(serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single integration
         * @param {string} serviceId 
         * @param {string} integration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesServiceIdIntegrationsIntegrationGet(serviceId: string, integration: string, options?: any): AxiosPromise<Integration> {
            return localVarFp.servicesServiceIdIntegrationsIntegrationGet(serviceId, integration, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an integration
         * @param {string} serviceId 
         * @param {string} integration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesServiceIdIntegrationsIntegrationPut(serviceId: string, integration: string, options?: any): AxiosPromise<object> {
            return localVarFp.servicesServiceIdIntegrationsIntegrationPut(serviceId, integration, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create or update a field mapping for an integration
         * @param {string} serviceId 
         * @param {string} integration 
         * @param {IntegrationFieldMappingInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFieldMapping(serviceId: string, integration: string, body?: IntegrationFieldMappingInput, options?: any): AxiosPromise<object> {
            return localVarFp.updateFieldMapping(serviceId, integration, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IntegrationsApi - object-oriented interface
 * @export
 * @class IntegrationsApi
 * @extends {BaseAPI}
 */
export class IntegrationsApi extends BaseAPI {
    /**
     * 
     * @summary Delete a field mapping for an integration
     * @param {string} serviceId 
     * @param {string} integration 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public deleteFieldMapping(serviceId: string, integration: string, options?: any) {
        return IntegrationsApiFp(this.configuration).deleteFieldMapping(serviceId, integration, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Disables an integration, deletes all integration config values, removes an integration-related auth tokens
     * @summary Disable an integration
     * @param {string} serviceId 
     * @param {string} integration 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public disableIntegration(serviceId: string, integration: string, options?: any) {
        return IntegrationsApiFp(this.configuration).disableIntegration(serviceId, integration, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Enable an integration for a service
     * @param {string} serviceId 
     * @param {string} integration 
     * @param {InlineObject1} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public enableIntegration(serviceId: string, integration: string, body?: InlineObject1, options?: any) {
        return IntegrationsApiFp(this.configuration).enableIntegration(serviceId, integration, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of all integrations for a service
     * @param {string} serviceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public getIntegration(serviceId: string, options?: any) {
        return IntegrationsApiFp(this.configuration).getIntegration(serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Generate an activation link for MindBody
     * @param {string} serviceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public getMindbodyActivationLink(serviceId: string, options?: any) {
        return IntegrationsApiFp(this.configuration).getMindbodyActivationLink(serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single integration
     * @param {string} serviceId 
     * @param {string} integration 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public servicesServiceIdIntegrationsIntegrationGet(serviceId: string, integration: string, options?: any) {
        return IntegrationsApiFp(this.configuration).servicesServiceIdIntegrationsIntegrationGet(serviceId, integration, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an integration
     * @param {string} serviceId 
     * @param {string} integration 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public servicesServiceIdIntegrationsIntegrationPut(serviceId: string, integration: string, options?: any) {
        return IntegrationsApiFp(this.configuration).servicesServiceIdIntegrationsIntegrationPut(serviceId, integration, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create or update a field mapping for an integration
     * @param {string} serviceId 
     * @param {string} integration 
     * @param {IntegrationFieldMappingInput} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public updateFieldMapping(serviceId: string, integration: string, body?: IntegrationFieldMappingInput, options?: any) {
        return IntegrationsApiFp(this.configuration).updateFieldMapping(serviceId, integration, body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MessageCategoriesApi - axios parameter creator
 * @export
 */
export const MessageCategoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Message Category
         * @param {string} serviceId 
         * @param {MessageCategoryInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMessageCategory: async (serviceId: string, body?: MessageCategoryInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('createMessageCategory', 'serviceId', serviceId)
            const localVarPath = `/services/{serviceId}/message-categories`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Message Category
         * @param {string} serviceId 
         * @param {string} messageCategoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMessageCategory: async (serviceId: string, messageCategoryId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('deleteMessageCategory', 'serviceId', serviceId)
            // verify required parameter 'messageCategoryId' is not null or undefined
            assertParamExists('deleteMessageCategory', 'messageCategoryId', messageCategoryId)
            const localVarPath = `/services/{serviceId}/message-categories/{messageCategoryId}`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)))
                .replace(`{${"messageCategoryId"}}`, encodeURIComponent(String(messageCategoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Message Category
         * @param {string} serviceId 
         * @param {string} messageCategoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageCategory: async (serviceId: string, messageCategoryId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('getMessageCategory', 'serviceId', serviceId)
            // verify required parameter 'messageCategoryId' is not null or undefined
            assertParamExists('getMessageCategory', 'messageCategoryId', messageCategoryId)
            const localVarPath = `/services/{serviceId}/message-categories/{messageCategoryId}`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)))
                .replace(`{${"messageCategoryId"}}`, encodeURIComponent(String(messageCategoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Message Categories
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMessageCategories: async (serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('listMessageCategories', 'serviceId', serviceId)
            const localVarPath = `/services/{serviceId}/message-categories`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Message Category
         * @param {string} serviceId 
         * @param {string} messageCategoryId 
         * @param {MessageCategoryInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMessageCategory: async (serviceId: string, messageCategoryId: string, body?: MessageCategoryInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('updateMessageCategory', 'serviceId', serviceId)
            // verify required parameter 'messageCategoryId' is not null or undefined
            assertParamExists('updateMessageCategory', 'messageCategoryId', messageCategoryId)
            const localVarPath = `/services/{serviceId}/message-categories/{messageCategoryId}`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)))
                .replace(`{${"messageCategoryId"}}`, encodeURIComponent(String(messageCategoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MessageCategoriesApi - functional programming interface
 * @export
 */
export const MessageCategoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MessageCategoriesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Message Category
         * @param {string} serviceId 
         * @param {MessageCategoryInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMessageCategory(serviceId: string, body?: MessageCategoryInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMessageCategory(serviceId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Message Category
         * @param {string} serviceId 
         * @param {string} messageCategoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMessageCategory(serviceId: string, messageCategoryId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMessageCategory(serviceId, messageCategoryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Message Category
         * @param {string} serviceId 
         * @param {string} messageCategoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMessageCategory(serviceId: string, messageCategoryId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMessageCategory(serviceId, messageCategoryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Message Categories
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMessageCategories(serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMessageCategories(serviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update Message Category
         * @param {string} serviceId 
         * @param {string} messageCategoryId 
         * @param {MessageCategoryInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMessageCategory(serviceId: string, messageCategoryId: string, body?: MessageCategoryInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMessageCategory(serviceId, messageCategoryId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MessageCategoriesApi - factory interface
 * @export
 */
export const MessageCategoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MessageCategoriesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Message Category
         * @param {string} serviceId 
         * @param {MessageCategoryInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMessageCategory(serviceId: string, body?: MessageCategoryInput, options?: any): AxiosPromise<void> {
            return localVarFp.createMessageCategory(serviceId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Message Category
         * @param {string} serviceId 
         * @param {string} messageCategoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMessageCategory(serviceId: string, messageCategoryId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteMessageCategory(serviceId, messageCategoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Message Category
         * @param {string} serviceId 
         * @param {string} messageCategoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageCategory(serviceId: string, messageCategoryId: string, options?: any): AxiosPromise<MessageCategory> {
            return localVarFp.getMessageCategory(serviceId, messageCategoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Message Categories
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMessageCategories(serviceId: string, options?: any): AxiosPromise<void> {
            return localVarFp.listMessageCategories(serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Message Category
         * @param {string} serviceId 
         * @param {string} messageCategoryId 
         * @param {MessageCategoryInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMessageCategory(serviceId: string, messageCategoryId: string, body?: MessageCategoryInput, options?: any): AxiosPromise<void> {
            return localVarFp.updateMessageCategory(serviceId, messageCategoryId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MessageCategoriesApi - object-oriented interface
 * @export
 * @class MessageCategoriesApi
 * @extends {BaseAPI}
 */
export class MessageCategoriesApi extends BaseAPI {
    /**
     * 
     * @summary Create Message Category
     * @param {string} serviceId 
     * @param {MessageCategoryInput} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageCategoriesApi
     */
    public createMessageCategory(serviceId: string, body?: MessageCategoryInput, options?: any) {
        return MessageCategoriesApiFp(this.configuration).createMessageCategory(serviceId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Message Category
     * @param {string} serviceId 
     * @param {string} messageCategoryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageCategoriesApi
     */
    public deleteMessageCategory(serviceId: string, messageCategoryId: string, options?: any) {
        return MessageCategoriesApiFp(this.configuration).deleteMessageCategory(serviceId, messageCategoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Message Category
     * @param {string} serviceId 
     * @param {string} messageCategoryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageCategoriesApi
     */
    public getMessageCategory(serviceId: string, messageCategoryId: string, options?: any) {
        return MessageCategoriesApiFp(this.configuration).getMessageCategory(serviceId, messageCategoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Message Categories
     * @param {string} serviceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageCategoriesApi
     */
    public listMessageCategories(serviceId: string, options?: any) {
        return MessageCategoriesApiFp(this.configuration).listMessageCategories(serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Message Category
     * @param {string} serviceId 
     * @param {string} messageCategoryId 
     * @param {MessageCategoryInput} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageCategoriesApi
     */
    public updateMessageCategory(serviceId: string, messageCategoryId: string, body?: MessageCategoryInput, options?: any) {
        return MessageCategoriesApiFp(this.configuration).updateMessageCategory(serviceId, messageCategoryId, body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MessagesApi - axios parameter creator
 * @export
 */
export const MessagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply message category
         * @param {string} serviceId 
         * @param {string} messageId 
         * @param {string} messageCategoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyMessageCategory: async (serviceId: string, messageId: string, messageCategoryId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('applyMessageCategory', 'serviceId', serviceId)
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('applyMessageCategory', 'messageId', messageId)
            // verify required parameter 'messageCategoryId' is not null or undefined
            assertParamExists('applyMessageCategory', 'messageCategoryId', messageCategoryId)
            const localVarPath = `/services/{serviceId}/messages/{messageId}/categories/{messageCategoryId}`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)))
                .replace(`{${"messageId"}}`, encodeURIComponent(String(messageId)))
                .replace(`{${"messageCategoryId"}}`, encodeURIComponent(String(messageCategoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} serviceId 
         * @param {string} messageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMessage: async (serviceId: string, messageId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('deleteMessage', 'serviceId', serviceId)
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('deleteMessage', 'messageId', messageId)
            const localVarPath = `/services/{serviceId}/messages/{messageId}`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)))
                .replace(`{${"messageId"}}`, encodeURIComponent(String(messageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove message category
         * @param {string} serviceId 
         * @param {string} messageId 
         * @param {string} messageCategoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMessageCategory: async (serviceId: string, messageId: string, messageCategoryId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('removeMessageCategory', 'serviceId', serviceId)
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('removeMessageCategory', 'messageId', messageId)
            // verify required parameter 'messageCategoryId' is not null or undefined
            assertParamExists('removeMessageCategory', 'messageCategoryId', messageCategoryId)
            const localVarPath = `/services/{serviceId}/messages/{messageId}/categories/{messageCategoryId}`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)))
                .replace(`{${"messageId"}}`, encodeURIComponent(String(messageId)))
                .replace(`{${"messageCategoryId"}}`, encodeURIComponent(String(messageCategoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send a message
         * @param {string} serviceId 
         * @param {MessageInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMessage: async (serviceId: string, body?: MessageInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('sendMessage', 'serviceId', serviceId)
            const localVarPath = `/services/{serviceId}/messages`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set message categories
         * @param {string} serviceId 
         * @param {string} messageId 
         * @param {Array<string>} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMessageCategories: async (serviceId: string, messageId: string, body?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('setMessageCategories', 'serviceId', serviceId)
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('setMessageCategories', 'messageId', messageId)
            const localVarPath = `/services/{serviceId}/messages/{messageId}/categories`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)))
                .replace(`{${"messageId"}}`, encodeURIComponent(String(messageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MessagesApi - functional programming interface
 * @export
 */
export const MessagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MessagesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Apply message category
         * @param {string} serviceId 
         * @param {string} messageId 
         * @param {string} messageCategoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async applyMessageCategory(serviceId: string, messageId: string, messageCategoryId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.applyMessageCategory(serviceId, messageId, messageCategoryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} serviceId 
         * @param {string} messageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMessage(serviceId: string, messageId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMessage(serviceId, messageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove message category
         * @param {string} serviceId 
         * @param {string} messageId 
         * @param {string} messageCategoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeMessageCategory(serviceId: string, messageId: string, messageCategoryId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeMessageCategory(serviceId, messageId, messageCategoryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Send a message
         * @param {string} serviceId 
         * @param {MessageInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendMessage(serviceId: string, body?: MessageInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendMessage(serviceId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Set message categories
         * @param {string} serviceId 
         * @param {string} messageId 
         * @param {Array<string>} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setMessageCategories(serviceId: string, messageId: string, body?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setMessageCategories(serviceId, messageId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MessagesApi - factory interface
 * @export
 */
export const MessagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MessagesApiFp(configuration)
    return {
        /**
         * 
         * @summary Apply message category
         * @param {string} serviceId 
         * @param {string} messageId 
         * @param {string} messageCategoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyMessageCategory(serviceId: string, messageId: string, messageCategoryId: string, options?: any): AxiosPromise<object> {
            return localVarFp.applyMessageCategory(serviceId, messageId, messageCategoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} serviceId 
         * @param {string} messageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMessage(serviceId: string, messageId: string, options?: any): AxiosPromise<object> {
            return localVarFp.deleteMessage(serviceId, messageId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove message category
         * @param {string} serviceId 
         * @param {string} messageId 
         * @param {string} messageCategoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMessageCategory(serviceId: string, messageId: string, messageCategoryId: string, options?: any): AxiosPromise<object> {
            return localVarFp.removeMessageCategory(serviceId, messageId, messageCategoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Send a message
         * @param {string} serviceId 
         * @param {MessageInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMessage(serviceId: string, body?: MessageInput, options?: any): AxiosPromise<object> {
            return localVarFp.sendMessage(serviceId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set message categories
         * @param {string} serviceId 
         * @param {string} messageId 
         * @param {Array<string>} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMessageCategories(serviceId: string, messageId: string, body?: Array<string>, options?: any): AxiosPromise<void> {
            return localVarFp.setMessageCategories(serviceId, messageId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MessagesApi - object-oriented interface
 * @export
 * @class MessagesApi
 * @extends {BaseAPI}
 */
export class MessagesApi extends BaseAPI {
    /**
     * 
     * @summary Apply message category
     * @param {string} serviceId 
     * @param {string} messageId 
     * @param {string} messageCategoryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public applyMessageCategory(serviceId: string, messageId: string, messageCategoryId: string, options?: any) {
        return MessagesApiFp(this.configuration).applyMessageCategory(serviceId, messageId, messageCategoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} serviceId 
     * @param {string} messageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public deleteMessage(serviceId: string, messageId: string, options?: any) {
        return MessagesApiFp(this.configuration).deleteMessage(serviceId, messageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove message category
     * @param {string} serviceId 
     * @param {string} messageId 
     * @param {string} messageCategoryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public removeMessageCategory(serviceId: string, messageId: string, messageCategoryId: string, options?: any) {
        return MessagesApiFp(this.configuration).removeMessageCategory(serviceId, messageId, messageCategoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Send a message
     * @param {string} serviceId 
     * @param {MessageInput} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public sendMessage(serviceId: string, body?: MessageInput, options?: any) {
        return MessagesApiFp(this.configuration).sendMessage(serviceId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set message categories
     * @param {string} serviceId 
     * @param {string} messageId 
     * @param {Array<string>} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public setMessageCategories(serviceId: string, messageId: string, body?: Array<string>, options?: any) {
        return MessagesApiFp(this.configuration).setMessageCategories(serviceId, messageId, body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrganizationContactImportsApi - axios parameter creator
 * @export
 */
export const OrganizationContactImportsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Imports a delimited file (CSV, TSV, pipe-delimited) for an organization using the organization\'s current import mapping configuration.
         * @summary Bulk Import Contacts into Organization Services
         * @param {string} organizationId 
         * @param {string} integration 
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationContactImport: async (organizationId: string, integration: string, body?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('organizationContactImport', 'organizationId', organizationId)
            // verify required parameter 'integration' is not null or undefined
            assertParamExists('organizationContactImport', 'integration', integration)
            const localVarPath = `/organizations/{organizationId}/bulk-import/{integration}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"integration"}}`, encodeURIComponent(String(integration)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'text/plain';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Disable integration mapping for organization
         * @param {string} organizationId 
         * @param {string} integration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsOrganizationIdContactImportConfigurationsIntegrationDelete: async (organizationId: string, integration: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('organizationsOrganizationIdContactImportConfigurationsIntegrationDelete', 'organizationId', organizationId)
            // verify required parameter 'integration' is not null or undefined
            assertParamExists('organizationsOrganizationIdContactImportConfigurationsIntegrationDelete', 'integration', integration)
            const localVarPath = `/organizations/{organizationId}/contact-import-configurations/{integration}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"integration"}}`, encodeURIComponent(String(integration)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Enable integration mapping on organization.
         * @param {string} organizationId 
         * @param {string} integration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsOrganizationIdContactImportConfigurationsIntegrationPost: async (organizationId: string, integration: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('organizationsOrganizationIdContactImportConfigurationsIntegrationPost', 'organizationId', organizationId)
            // verify required parameter 'integration' is not null or undefined
            assertParamExists('organizationsOrganizationIdContactImportConfigurationsIntegrationPost', 'integration', integration)
            const localVarPath = `/organizations/{organizationId}/contact-import-configurations/{integration}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"integration"}}`, encodeURIComponent(String(integration)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add mapping configuration for organization integration
         * @param {string} organizationId 
         * @param {string} integration 
         * @param {InlineObject12} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsOrganizationIdContactImportConfigurationsIntegrationPut: async (organizationId: string, integration: string, body?: InlineObject12, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('organizationsOrganizationIdContactImportConfigurationsIntegrationPut', 'organizationId', organizationId)
            // verify required parameter 'integration' is not null or undefined
            assertParamExists('organizationsOrganizationIdContactImportConfigurationsIntegrationPut', 'integration', integration)
            const localVarPath = `/organizations/{organizationId}/contact-import-configurations/{integration}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"integration"}}`, encodeURIComponent(String(integration)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationContactImportsApi - functional programming interface
 * @export
 */
export const OrganizationContactImportsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationContactImportsApiAxiosParamCreator(configuration)
    return {
        /**
         * Imports a delimited file (CSV, TSV, pipe-delimited) for an organization using the organization\'s current import mapping configuration.
         * @summary Bulk Import Contacts into Organization Services
         * @param {string} organizationId 
         * @param {string} integration 
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationContactImport(organizationId: string, integration: string, body?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationContactImport(organizationId, integration, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Disable integration mapping for organization
         * @param {string} organizationId 
         * @param {string} integration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationsOrganizationIdContactImportConfigurationsIntegrationDelete(organizationId: string, integration: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationsOrganizationIdContactImportConfigurationsIntegrationDelete(organizationId, integration, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Enable integration mapping on organization.
         * @param {string} organizationId 
         * @param {string} integration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationsOrganizationIdContactImportConfigurationsIntegrationPost(organizationId: string, integration: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationsOrganizationIdContactImportConfigurationsIntegrationPost(organizationId, integration, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add mapping configuration for organization integration
         * @param {string} organizationId 
         * @param {string} integration 
         * @param {InlineObject12} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationsOrganizationIdContactImportConfigurationsIntegrationPut(organizationId: string, integration: string, body?: InlineObject12, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationsOrganizationIdContactImportConfigurationsIntegrationPut(organizationId, integration, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrganizationContactImportsApi - factory interface
 * @export
 */
export const OrganizationContactImportsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationContactImportsApiFp(configuration)
    return {
        /**
         * Imports a delimited file (CSV, TSV, pipe-delimited) for an organization using the organization\'s current import mapping configuration.
         * @summary Bulk Import Contacts into Organization Services
         * @param {string} organizationId 
         * @param {string} integration 
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationContactImport(organizationId: string, integration: string, body?: string, options?: any): AxiosPromise<object> {
            return localVarFp.organizationContactImport(organizationId, integration, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Disable integration mapping for organization
         * @param {string} organizationId 
         * @param {string} integration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsOrganizationIdContactImportConfigurationsIntegrationDelete(organizationId: string, integration: string, options?: any): AxiosPromise<object> {
            return localVarFp.organizationsOrganizationIdContactImportConfigurationsIntegrationDelete(organizationId, integration, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Enable integration mapping on organization.
         * @param {string} organizationId 
         * @param {string} integration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsOrganizationIdContactImportConfigurationsIntegrationPost(organizationId: string, integration: string, options?: any): AxiosPromise<object> {
            return localVarFp.organizationsOrganizationIdContactImportConfigurationsIntegrationPost(organizationId, integration, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add mapping configuration for organization integration
         * @param {string} organizationId 
         * @param {string} integration 
         * @param {InlineObject12} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsOrganizationIdContactImportConfigurationsIntegrationPut(organizationId: string, integration: string, body?: InlineObject12, options?: any): AxiosPromise<object> {
            return localVarFp.organizationsOrganizationIdContactImportConfigurationsIntegrationPut(organizationId, integration, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationContactImportsApi - object-oriented interface
 * @export
 * @class OrganizationContactImportsApi
 * @extends {BaseAPI}
 */
export class OrganizationContactImportsApi extends BaseAPI {
    /**
     * Imports a delimited file (CSV, TSV, pipe-delimited) for an organization using the organization\'s current import mapping configuration.
     * @summary Bulk Import Contacts into Organization Services
     * @param {string} organizationId 
     * @param {string} integration 
     * @param {string} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationContactImportsApi
     */
    public organizationContactImport(organizationId: string, integration: string, body?: string, options?: any) {
        return OrganizationContactImportsApiFp(this.configuration).organizationContactImport(organizationId, integration, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Disable integration mapping for organization
     * @param {string} organizationId 
     * @param {string} integration 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationContactImportsApi
     */
    public organizationsOrganizationIdContactImportConfigurationsIntegrationDelete(organizationId: string, integration: string, options?: any) {
        return OrganizationContactImportsApiFp(this.configuration).organizationsOrganizationIdContactImportConfigurationsIntegrationDelete(organizationId, integration, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Enable integration mapping on organization.
     * @param {string} organizationId 
     * @param {string} integration 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationContactImportsApi
     */
    public organizationsOrganizationIdContactImportConfigurationsIntegrationPost(organizationId: string, integration: string, options?: any) {
        return OrganizationContactImportsApiFp(this.configuration).organizationsOrganizationIdContactImportConfigurationsIntegrationPost(organizationId, integration, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add mapping configuration for organization integration
     * @param {string} organizationId 
     * @param {string} integration 
     * @param {InlineObject12} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationContactImportsApi
     */
    public organizationsOrganizationIdContactImportConfigurationsIntegrationPut(organizationId: string, integration: string, body?: InlineObject12, options?: any) {
        return OrganizationContactImportsApiFp(this.configuration).organizationsOrganizationIdContactImportConfigurationsIntegrationPut(organizationId, integration, body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrganizationsApi - axios parameter creator
 * @export
 */
export const OrganizationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Return events that belong to services in organization
         * @param {string} organizationId 
         * @param {string} [start] 
         * @param {string} [end] 
         * @param {boolean} [groupByContact] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationEvents: async (organizationId: string, start?: string, end?: string, groupByContact?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationEvents', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organizationId}/events`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString() :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString() :
                    end;
            }

            if (groupByContact !== undefined) {
                localVarQueryParameter['group_by_contact'] = groupByContact;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Paginate organizations
         * @param {number} page 
         * @param {string} query 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsGet: async (page: number, query: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'page' is not null or undefined
            assertParamExists('organizationsGet', 'page', page)
            // verify required parameter 'query' is not null or undefined
            assertParamExists('organizationsGet', 'query', query)
            const localVarPath = `/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete organization
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsOrganizationIdDelete: async (organizationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('organizationsOrganizationIdDelete', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organizationId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve organization
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsOrganizationIdGet: async (organizationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('organizationsOrganizationIdGet', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organizationId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update organization
         * @param {string} organizationId 
         * @param {InlineObject14} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsOrganizationIdPut: async (organizationId: string, body?: InlineObject14, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('organizationsOrganizationIdPut', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organizationId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of services in organization
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsOrganizationIdServicesGet: async (organizationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('organizationsOrganizationIdServicesGet', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organizationId}/services`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove service from organization
         * @param {string} organizationId 
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsOrganizationIdServicesServiceIdDelete: async (organizationId: string, serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('organizationsOrganizationIdServicesServiceIdDelete', 'organizationId', organizationId)
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('organizationsOrganizationIdServicesServiceIdDelete', 'serviceId', serviceId)
            const localVarPath = `/organizations/{organizationId}/services/{serviceId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a service to an organization
         * @param {string} organizationId 
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsOrganizationIdServicesServiceIdPost: async (organizationId: string, serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('organizationsOrganizationIdServicesServiceIdPost', 'organizationId', organizationId)
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('organizationsOrganizationIdServicesServiceIdPost', 'serviceId', serviceId)
            const localVarPath = `/organizations/{organizationId}/services/{serviceId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User organization search
         * @param {string} organizationId 
         * @param {string} [q] Query term
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsOrganizationIdUsersGet: async (organizationId: string, q?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('organizationsOrganizationIdUsersGet', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organizationId}/users`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add user to organization
         * @param {string} organizationId 
         * @param {InlineObject15} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsOrganizationIdUsersPost: async (organizationId: string, body?: InlineObject15, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('organizationsOrganizationIdUsersPost', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organizationId}/users`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove user from organization
         * @param {string} organizationId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsOrganizationIdUsersUserIdDelete: async (organizationId: string, userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('organizationsOrganizationIdUsersUserIdDelete', 'organizationId', organizationId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('organizationsOrganizationIdUsersUserIdDelete', 'userId', userId)
            const localVarPath = `/organizations/{organizationId}/users/{userId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update user org role
         * @param {string} organizationId 
         * @param {string} userId 
         * @param {InlineObject16} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsOrganizationIdUsersUserIdPut: async (organizationId: string, userId: string, body?: InlineObject16, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('organizationsOrganizationIdUsersUserIdPut', 'organizationId', organizationId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('organizationsOrganizationIdUsersUserIdPut', 'userId', userId)
            const localVarPath = `/organizations/{organizationId}/users/{userId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an organization
         * @param {InlineObject13} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsPost: async (body?: InlineObject13, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationsApi - functional programming interface
 * @export
 */
export const OrganizationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Return events that belong to services in organization
         * @param {string} organizationId 
         * @param {string} [start] 
         * @param {string} [end] 
         * @param {boolean} [groupByContact] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationEvents(organizationId: string, start?: string, end?: string, groupByContact?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationEvents(organizationId, start, end, groupByContact, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Paginate organizations
         * @param {number} page 
         * @param {string} query 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationsGet(page: number, query: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20015>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationsGet(page, query, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete organization
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationsOrganizationIdDelete(organizationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationsOrganizationIdDelete(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve organization
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationsOrganizationIdGet(organizationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20015Items>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationsOrganizationIdGet(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update organization
         * @param {string} organizationId 
         * @param {InlineObject14} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationsOrganizationIdPut(organizationId: string, body?: InlineObject14, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationsOrganizationIdPut(organizationId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get list of services in organization
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationsOrganizationIdServicesGet(organizationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationsOrganizationIdServicesGet(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove service from organization
         * @param {string} organizationId 
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationsOrganizationIdServicesServiceIdDelete(organizationId: string, serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationsOrganizationIdServicesServiceIdDelete(organizationId, serviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a service to an organization
         * @param {string} organizationId 
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationsOrganizationIdServicesServiceIdPost(organizationId: string, serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationsOrganizationIdServicesServiceIdPost(organizationId, serviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary User organization search
         * @param {string} organizationId 
         * @param {string} [q] Query term
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationsOrganizationIdUsersGet(organizationId: string, q?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationsOrganizationIdUsersGet(organizationId, q, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add user to organization
         * @param {string} organizationId 
         * @param {InlineObject15} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationsOrganizationIdUsersPost(organizationId: string, body?: InlineObject15, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationsOrganizationIdUsersPost(organizationId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove user from organization
         * @param {string} organizationId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationsOrganizationIdUsersUserIdDelete(organizationId: string, userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationsOrganizationIdUsersUserIdDelete(organizationId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update user org role
         * @param {string} organizationId 
         * @param {string} userId 
         * @param {InlineObject16} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationsOrganizationIdUsersUserIdPut(organizationId: string, userId: string, body?: InlineObject16, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationsOrganizationIdUsersUserIdPut(organizationId, userId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create an organization
         * @param {InlineObject13} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationsPost(body?: InlineObject13, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationsPost(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrganizationsApi - factory interface
 * @export
 */
export const OrganizationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationsApiFp(configuration)
    return {
        /**
         * 
         * @summary Return events that belong to services in organization
         * @param {string} organizationId 
         * @param {string} [start] 
         * @param {string} [end] 
         * @param {boolean} [groupByContact] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationEvents(organizationId: string, start?: string, end?: string, groupByContact?: boolean, options?: any): AxiosPromise<object> {
            return localVarFp.getOrganizationEvents(organizationId, start, end, groupByContact, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Paginate organizations
         * @param {number} page 
         * @param {string} query 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsGet(page: number, query: string, options?: any): AxiosPromise<InlineResponse20015> {
            return localVarFp.organizationsGet(page, query, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete organization
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsOrganizationIdDelete(organizationId: string, options?: any): AxiosPromise<object> {
            return localVarFp.organizationsOrganizationIdDelete(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve organization
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsOrganizationIdGet(organizationId: string, options?: any): AxiosPromise<InlineResponse20015Items> {
            return localVarFp.organizationsOrganizationIdGet(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update organization
         * @param {string} organizationId 
         * @param {InlineObject14} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsOrganizationIdPut(organizationId: string, body?: InlineObject14, options?: any): AxiosPromise<object> {
            return localVarFp.organizationsOrganizationIdPut(organizationId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get list of services in organization
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsOrganizationIdServicesGet(organizationId: string, options?: any): AxiosPromise<object> {
            return localVarFp.organizationsOrganizationIdServicesGet(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove service from organization
         * @param {string} organizationId 
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsOrganizationIdServicesServiceIdDelete(organizationId: string, serviceId: string, options?: any): AxiosPromise<object> {
            return localVarFp.organizationsOrganizationIdServicesServiceIdDelete(organizationId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a service to an organization
         * @param {string} organizationId 
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsOrganizationIdServicesServiceIdPost(organizationId: string, serviceId: string, options?: any): AxiosPromise<object> {
            return localVarFp.organizationsOrganizationIdServicesServiceIdPost(organizationId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary User organization search
         * @param {string} organizationId 
         * @param {string} [q] Query term
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsOrganizationIdUsersGet(organizationId: string, q?: string, options?: any): AxiosPromise<object> {
            return localVarFp.organizationsOrganizationIdUsersGet(organizationId, q, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add user to organization
         * @param {string} organizationId 
         * @param {InlineObject15} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsOrganizationIdUsersPost(organizationId: string, body?: InlineObject15, options?: any): AxiosPromise<object> {
            return localVarFp.organizationsOrganizationIdUsersPost(organizationId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove user from organization
         * @param {string} organizationId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsOrganizationIdUsersUserIdDelete(organizationId: string, userId: string, options?: any): AxiosPromise<object> {
            return localVarFp.organizationsOrganizationIdUsersUserIdDelete(organizationId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update user org role
         * @param {string} organizationId 
         * @param {string} userId 
         * @param {InlineObject16} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsOrganizationIdUsersUserIdPut(organizationId: string, userId: string, body?: InlineObject16, options?: any): AxiosPromise<object> {
            return localVarFp.organizationsOrganizationIdUsersUserIdPut(organizationId, userId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create an organization
         * @param {InlineObject13} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsPost(body?: InlineObject13, options?: any): AxiosPromise<object> {
            return localVarFp.organizationsPost(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationsApi - object-oriented interface
 * @export
 * @class OrganizationsApi
 * @extends {BaseAPI}
 */
export class OrganizationsApi extends BaseAPI {
    /**
     * 
     * @summary Return events that belong to services in organization
     * @param {string} organizationId 
     * @param {string} [start] 
     * @param {string} [end] 
     * @param {boolean} [groupByContact] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getOrganizationEvents(organizationId: string, start?: string, end?: string, groupByContact?: boolean, options?: any) {
        return OrganizationsApiFp(this.configuration).getOrganizationEvents(organizationId, start, end, groupByContact, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Paginate organizations
     * @param {number} page 
     * @param {string} query 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public organizationsGet(page: number, query: string, options?: any) {
        return OrganizationsApiFp(this.configuration).organizationsGet(page, query, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete organization
     * @param {string} organizationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public organizationsOrganizationIdDelete(organizationId: string, options?: any) {
        return OrganizationsApiFp(this.configuration).organizationsOrganizationIdDelete(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve organization
     * @param {string} organizationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public organizationsOrganizationIdGet(organizationId: string, options?: any) {
        return OrganizationsApiFp(this.configuration).organizationsOrganizationIdGet(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update organization
     * @param {string} organizationId 
     * @param {InlineObject14} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public organizationsOrganizationIdPut(organizationId: string, body?: InlineObject14, options?: any) {
        return OrganizationsApiFp(this.configuration).organizationsOrganizationIdPut(organizationId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get list of services in organization
     * @param {string} organizationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public organizationsOrganizationIdServicesGet(organizationId: string, options?: any) {
        return OrganizationsApiFp(this.configuration).organizationsOrganizationIdServicesGet(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove service from organization
     * @param {string} organizationId 
     * @param {string} serviceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public organizationsOrganizationIdServicesServiceIdDelete(organizationId: string, serviceId: string, options?: any) {
        return OrganizationsApiFp(this.configuration).organizationsOrganizationIdServicesServiceIdDelete(organizationId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a service to an organization
     * @param {string} organizationId 
     * @param {string} serviceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public organizationsOrganizationIdServicesServiceIdPost(organizationId: string, serviceId: string, options?: any) {
        return OrganizationsApiFp(this.configuration).organizationsOrganizationIdServicesServiceIdPost(organizationId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary User organization search
     * @param {string} organizationId 
     * @param {string} [q] Query term
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public organizationsOrganizationIdUsersGet(organizationId: string, q?: string, options?: any) {
        return OrganizationsApiFp(this.configuration).organizationsOrganizationIdUsersGet(organizationId, q, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add user to organization
     * @param {string} organizationId 
     * @param {InlineObject15} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public organizationsOrganizationIdUsersPost(organizationId: string, body?: InlineObject15, options?: any) {
        return OrganizationsApiFp(this.configuration).organizationsOrganizationIdUsersPost(organizationId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove user from organization
     * @param {string} organizationId 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public organizationsOrganizationIdUsersUserIdDelete(organizationId: string, userId: string, options?: any) {
        return OrganizationsApiFp(this.configuration).organizationsOrganizationIdUsersUserIdDelete(organizationId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update user org role
     * @param {string} organizationId 
     * @param {string} userId 
     * @param {InlineObject16} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public organizationsOrganizationIdUsersUserIdPut(organizationId: string, userId: string, body?: InlineObject16, options?: any) {
        return OrganizationsApiFp(this.configuration).organizationsOrganizationIdUsersUserIdPut(organizationId, userId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create an organization
     * @param {InlineObject13} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public organizationsPost(body?: InlineObject13, options?: any) {
        return OrganizationsApiFp(this.configuration).organizationsPost(body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PhoneNumbersApi - axios parameter creator
 * @export
 */
export const PhoneNumbersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Provision a phone number
         * @param {PhoneNumberInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provisionPhoneNumber: async (body?: PhoneNumberInput, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/phone-numbers/provision`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PhoneNumbersApi - functional programming interface
 * @export
 */
export const PhoneNumbersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PhoneNumbersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Provision a phone number
         * @param {PhoneNumberInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provisionPhoneNumber(body?: PhoneNumberInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provisionPhoneNumber(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PhoneNumbersApi - factory interface
 * @export
 */
export const PhoneNumbersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PhoneNumbersApiFp(configuration)
    return {
        /**
         * 
         * @summary Provision a phone number
         * @param {PhoneNumberInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provisionPhoneNumber(body?: PhoneNumberInput, options?: any): AxiosPromise<object> {
            return localVarFp.provisionPhoneNumber(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PhoneNumbersApi - object-oriented interface
 * @export
 * @class PhoneNumbersApi
 * @extends {BaseAPI}
 */
export class PhoneNumbersApi extends BaseAPI {
    /**
     * 
     * @summary Provision a phone number
     * @param {PhoneNumberInput} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhoneNumbersApi
     */
    public provisionPhoneNumber(body?: PhoneNumberInput, options?: any) {
        return PhoneNumbersApiFp(this.configuration).provisionPhoneNumber(body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SecurityApi - axios parameter creator
 * @export
 */
export const SecurityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Exchange an access code for a jwt token
         * @param {InlineObject11} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        securityOauthExchange: async (body?: InlineObject11, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/oauth/exchange`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a JWT token used for Auth
         * @param {string} [privilege] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenPost: async (privilege?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (privilege !== undefined) {
                localVarQueryParameter['privilege'] = privilege;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Refresh JWT Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenRefreshGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/token/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SecurityApi - functional programming interface
 * @export
 */
export const SecurityApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SecurityApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Exchange an access code for a jwt token
         * @param {InlineObject11} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async securityOauthExchange(body?: InlineObject11, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20013>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.securityOauthExchange(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a JWT token used for Auth
         * @param {string} [privilege] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenPost(privilege?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20014>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenPost(privilege, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Refresh JWT Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenRefreshGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20014>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenRefreshGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SecurityApi - factory interface
 * @export
 */
export const SecurityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SecurityApiFp(configuration)
    return {
        /**
         * 
         * @summary Exchange an access code for a jwt token
         * @param {InlineObject11} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        securityOauthExchange(body?: InlineObject11, options?: any): AxiosPromise<InlineResponse20013> {
            return localVarFp.securityOauthExchange(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a JWT token used for Auth
         * @param {string} [privilege] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenPost(privilege?: string, options?: any): AxiosPromise<InlineResponse20014> {
            return localVarFp.tokenPost(privilege, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Refresh JWT Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenRefreshGet(options?: any): AxiosPromise<InlineResponse20014> {
            return localVarFp.tokenRefreshGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SecurityApi - object-oriented interface
 * @export
 * @class SecurityApi
 * @extends {BaseAPI}
 */
export class SecurityApi extends BaseAPI {
    /**
     * 
     * @summary Exchange an access code for a jwt token
     * @param {InlineObject11} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    public securityOauthExchange(body?: InlineObject11, options?: any) {
        return SecurityApiFp(this.configuration).securityOauthExchange(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a JWT token used for Auth
     * @param {string} [privilege] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    public tokenPost(privilege?: string, options?: any) {
        return SecurityApiFp(this.configuration).tokenPost(privilege, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Refresh JWT Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    public tokenRefreshGet(options?: any) {
        return SecurityApiFp(this.configuration).tokenRefreshGet(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SegmentsApi - axios parameter creator
 * @export
 */
export const SegmentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Segment
         * @param {string} serviceId 
         * @param {string} segmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSegment: async (serviceId: string, segmentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('getSegment', 'serviceId', serviceId)
            // verify required parameter 'segmentId' is not null or undefined
            assertParamExists('getSegment', 'segmentId', segmentId)
            const localVarPath = `/services/{serviceId}/segments/{segmentId}`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)))
                .replace(`{${"segmentId"}}`, encodeURIComponent(String(segmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Segments
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesServiceIdSegmentsGet: async (serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('servicesServiceIdSegmentsGet', 'serviceId', serviceId)
            const localVarPath = `/services/{serviceId}/segments`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Segment
         * @param {string} serviceId 
         * @param {SegmentInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesServiceIdSegmentsPost: async (serviceId: string, body?: SegmentInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('servicesServiceIdSegmentsPost', 'serviceId', serviceId)
            const localVarPath = `/services/{serviceId}/segments`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Segment
         * @param {string} serviceId 
         * @param {string} segmentId 
         * @param {SegmentInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesServiceIdSegmentsSegmentIdPut: async (serviceId: string, segmentId: string, body?: SegmentInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('servicesServiceIdSegmentsSegmentIdPut', 'serviceId', serviceId)
            // verify required parameter 'segmentId' is not null or undefined
            assertParamExists('servicesServiceIdSegmentsSegmentIdPut', 'segmentId', segmentId)
            const localVarPath = `/services/{serviceId}/segments/{segmentId}`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)))
                .replace(`{${"segmentId"}}`, encodeURIComponent(String(segmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SegmentsApi - functional programming interface
 * @export
 */
export const SegmentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SegmentsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Segment
         * @param {string} serviceId 
         * @param {string} segmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSegment(serviceId: string, segmentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Segment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSegment(serviceId, segmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Segments
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async servicesServiceIdSegmentsGet(serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Segment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicesServiceIdSegmentsGet(serviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create Segment
         * @param {string} serviceId 
         * @param {SegmentInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async servicesServiceIdSegmentsPost(serviceId: string, body?: SegmentInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicesServiceIdSegmentsPost(serviceId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update Segment
         * @param {string} serviceId 
         * @param {string} segmentId 
         * @param {SegmentInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async servicesServiceIdSegmentsSegmentIdPut(serviceId: string, segmentId: string, body?: SegmentInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicesServiceIdSegmentsSegmentIdPut(serviceId, segmentId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SegmentsApi - factory interface
 * @export
 */
export const SegmentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SegmentsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Segment
         * @param {string} serviceId 
         * @param {string} segmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSegment(serviceId: string, segmentId: string, options?: any): AxiosPromise<Segment> {
            return localVarFp.getSegment(serviceId, segmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Segments
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesServiceIdSegmentsGet(serviceId: string, options?: any): AxiosPromise<Array<Segment>> {
            return localVarFp.servicesServiceIdSegmentsGet(serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Segment
         * @param {string} serviceId 
         * @param {SegmentInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesServiceIdSegmentsPost(serviceId: string, body?: SegmentInput, options?: any): AxiosPromise<void> {
            return localVarFp.servicesServiceIdSegmentsPost(serviceId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Segment
         * @param {string} serviceId 
         * @param {string} segmentId 
         * @param {SegmentInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesServiceIdSegmentsSegmentIdPut(serviceId: string, segmentId: string, body?: SegmentInput, options?: any): AxiosPromise<void> {
            return localVarFp.servicesServiceIdSegmentsSegmentIdPut(serviceId, segmentId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SegmentsApi - object-oriented interface
 * @export
 * @class SegmentsApi
 * @extends {BaseAPI}
 */
export class SegmentsApi extends BaseAPI {
    /**
     * 
     * @summary Get Segment
     * @param {string} serviceId 
     * @param {string} segmentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public getSegment(serviceId: string, segmentId: string, options?: any) {
        return SegmentsApiFp(this.configuration).getSegment(serviceId, segmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Segments
     * @param {string} serviceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public servicesServiceIdSegmentsGet(serviceId: string, options?: any) {
        return SegmentsApiFp(this.configuration).servicesServiceIdSegmentsGet(serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Segment
     * @param {string} serviceId 
     * @param {SegmentInput} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public servicesServiceIdSegmentsPost(serviceId: string, body?: SegmentInput, options?: any) {
        return SegmentsApiFp(this.configuration).servicesServiceIdSegmentsPost(serviceId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Segment
     * @param {string} serviceId 
     * @param {string} segmentId 
     * @param {SegmentInput} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public servicesServiceIdSegmentsSegmentIdPut(serviceId: string, segmentId: string, body?: SegmentInput, options?: any) {
        return SegmentsApiFp(this.configuration).servicesServiceIdSegmentsSegmentIdPut(serviceId, segmentId, body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ServiceCollectionsApi - axios parameter creator
 * @export
 */
export const ServiceCollectionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add service to service collection
         * @param {string} serviceCollectionId 
         * @param {string} serviceId 
         * @param {ServiceCollectionServiceInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addServiceToServiceCollection: async (serviceCollectionId: string, serviceId: string, body?: ServiceCollectionServiceInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceCollectionId' is not null or undefined
            assertParamExists('addServiceToServiceCollection', 'serviceCollectionId', serviceCollectionId)
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('addServiceToServiceCollection', 'serviceId', serviceId)
            const localVarPath = `/service-collections/{serviceCollectionId}/services/{serviceId}`
                .replace(`{${"serviceCollectionId"}}`, encodeURIComponent(String(serviceCollectionId)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a Service Collection
         * @param {ServiceCollectionInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createServiceCollection: async (body?: ServiceCollectionInput, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/service-collections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Service Collection Field
         * @param {string} serviceCollectionId 
         * @param {ServiceCollectionFieldInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createServiceCollectionField: async (serviceCollectionId: string, body?: ServiceCollectionFieldInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceCollectionId' is not null or undefined
            assertParamExists('createServiceCollectionField', 'serviceCollectionId', serviceCollectionId)
            const localVarPath = `/service-collections/{serviceCollectionId}/fields`
                .replace(`{${"serviceCollectionId"}}`, encodeURIComponent(String(serviceCollectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a Service Collection
         * @param {string} serviceCollectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteServiceCollection: async (serviceCollectionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceCollectionId' is not null or undefined
            assertParamExists('deleteServiceCollection', 'serviceCollectionId', serviceCollectionId)
            const localVarPath = `/service-collections/{serviceCollectionId}`
                .replace(`{${"serviceCollectionId"}}`, encodeURIComponent(String(serviceCollectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete field from Service Collection
         * @param {string} serviceCollectionId 
         * @param {string} fieldId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteServiceCollectionField: async (serviceCollectionId: string, fieldId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceCollectionId' is not null or undefined
            assertParamExists('deleteServiceCollectionField', 'serviceCollectionId', serviceCollectionId)
            // verify required parameter 'fieldId' is not null or undefined
            assertParamExists('deleteServiceCollectionField', 'fieldId', fieldId)
            const localVarPath = `/service-collections/{serviceCollectionId}/fields/{fieldId}`
                .replace(`{${"serviceCollectionId"}}`, encodeURIComponent(String(serviceCollectionId)))
                .replace(`{${"fieldId"}}`, encodeURIComponent(String(fieldId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Service Collection Services
         * @param {string} serviceCollectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServiceCollectionServices: async (serviceCollectionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceCollectionId' is not null or undefined
            assertParamExists('listServiceCollectionServices', 'serviceCollectionId', serviceCollectionId)
            const localVarPath = `/service-collections/{serviceCollectionId}/services`
                .replace(`{${"serviceCollectionId"}}`, encodeURIComponent(String(serviceCollectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all service collections
         * @summary List all Service Collections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServiceCollections: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/service-collections/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all service collections that a current user has access to through their Service roles
         * @summary List Service Collections for user
         * @param {string} [serviceId]  Only return collections containing the specified service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserServiceCollections: async (serviceId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/service-collections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (serviceId !== undefined) {
                localVarQueryParameter['service_id'] = serviceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove service from service collection
         * @param {string} serviceCollectionId 
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeServiceFromServiceCollection: async (serviceCollectionId: string, serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceCollectionId' is not null or undefined
            assertParamExists('removeServiceFromServiceCollection', 'serviceCollectionId', serviceCollectionId)
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('removeServiceFromServiceCollection', 'serviceId', serviceId)
            const localVarPath = `/service-collections/{serviceCollectionId}/services/{serviceId}`
                .replace(`{${"serviceCollectionId"}}`, encodeURIComponent(String(serviceCollectionId)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Service Collection
         * @param {string} serviceCollectionId 
         * @param {ServiceCollectionInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateServiceCollection: async (serviceCollectionId: string, body?: ServiceCollectionInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceCollectionId' is not null or undefined
            assertParamExists('updateServiceCollection', 'serviceCollectionId', serviceCollectionId)
            const localVarPath = `/service-collections/{serviceCollectionId}`
                .replace(`{${"serviceCollectionId"}}`, encodeURIComponent(String(serviceCollectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update service collection field
         * @param {string} serviceCollectionId 
         * @param {string} fieldId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateServiceCollectionField: async (serviceCollectionId: string, fieldId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceCollectionId' is not null or undefined
            assertParamExists('updateServiceCollectionField', 'serviceCollectionId', serviceCollectionId)
            // verify required parameter 'fieldId' is not null or undefined
            assertParamExists('updateServiceCollectionField', 'fieldId', fieldId)
            const localVarPath = `/service-collections/{serviceCollectionId}/fields/{fieldId}`
                .replace(`{${"serviceCollectionId"}}`, encodeURIComponent(String(serviceCollectionId)))
                .replace(`{${"fieldId"}}`, encodeURIComponent(String(fieldId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update service for service collection
         * @param {string} serviceCollectionId 
         * @param {string} serviceId 
         * @param {ServiceCollectionServiceInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateServiceForServiceCollection: async (serviceCollectionId: string, serviceId: string, body?: ServiceCollectionServiceInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceCollectionId' is not null or undefined
            assertParamExists('updateServiceForServiceCollection', 'serviceCollectionId', serviceCollectionId)
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('updateServiceForServiceCollection', 'serviceId', serviceId)
            const localVarPath = `/service-collections/{serviceCollectionId}/services/{serviceId}`
                .replace(`{${"serviceCollectionId"}}`, encodeURIComponent(String(serviceCollectionId)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServiceCollectionsApi - functional programming interface
 * @export
 */
export const ServiceCollectionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServiceCollectionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add service to service collection
         * @param {string} serviceCollectionId 
         * @param {string} serviceId 
         * @param {ServiceCollectionServiceInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addServiceToServiceCollection(serviceCollectionId: string, serviceId: string, body?: ServiceCollectionServiceInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceCollectionServiceInput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addServiceToServiceCollection(serviceCollectionId, serviceId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a Service Collection
         * @param {ServiceCollectionInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createServiceCollection(body?: ServiceCollectionInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createServiceCollection(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create Service Collection Field
         * @param {string} serviceCollectionId 
         * @param {ServiceCollectionFieldInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createServiceCollectionField(serviceCollectionId: string, body?: ServiceCollectionFieldInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createServiceCollectionField(serviceCollectionId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a Service Collection
         * @param {string} serviceCollectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteServiceCollection(serviceCollectionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteServiceCollection(serviceCollectionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete field from Service Collection
         * @param {string} serviceCollectionId 
         * @param {string} fieldId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteServiceCollectionField(serviceCollectionId: string, fieldId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteServiceCollectionField(serviceCollectionId, fieldId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Service Collection Services
         * @param {string} serviceCollectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listServiceCollectionServices(serviceCollectionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ServiceCollectionService>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listServiceCollectionServices(serviceCollectionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all service collections
         * @summary List all Service Collections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listServiceCollections(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ServiceCollection>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listServiceCollections(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists all service collections that a current user has access to through their Service roles
         * @summary List Service Collections for user
         * @param {string} [serviceId]  Only return collections containing the specified service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserServiceCollections(serviceId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ServiceCollection>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUserServiceCollections(serviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove service from service collection
         * @param {string} serviceCollectionId 
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeServiceFromServiceCollection(serviceCollectionId: string, serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeServiceFromServiceCollection(serviceCollectionId, serviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update Service Collection
         * @param {string} serviceCollectionId 
         * @param {ServiceCollectionInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateServiceCollection(serviceCollectionId: string, body?: ServiceCollectionInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateServiceCollection(serviceCollectionId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update service collection field
         * @param {string} serviceCollectionId 
         * @param {string} fieldId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateServiceCollectionField(serviceCollectionId: string, fieldId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateServiceCollectionField(serviceCollectionId, fieldId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update service for service collection
         * @param {string} serviceCollectionId 
         * @param {string} serviceId 
         * @param {ServiceCollectionServiceInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateServiceForServiceCollection(serviceCollectionId: string, serviceId: string, body?: ServiceCollectionServiceInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateServiceForServiceCollection(serviceCollectionId, serviceId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ServiceCollectionsApi - factory interface
 * @export
 */
export const ServiceCollectionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServiceCollectionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Add service to service collection
         * @param {string} serviceCollectionId 
         * @param {string} serviceId 
         * @param {ServiceCollectionServiceInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addServiceToServiceCollection(serviceCollectionId: string, serviceId: string, body?: ServiceCollectionServiceInput, options?: any): AxiosPromise<ServiceCollectionServiceInput> {
            return localVarFp.addServiceToServiceCollection(serviceCollectionId, serviceId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a Service Collection
         * @param {ServiceCollectionInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createServiceCollection(body?: ServiceCollectionInput, options?: any): AxiosPromise<object> {
            return localVarFp.createServiceCollection(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Service Collection Field
         * @param {string} serviceCollectionId 
         * @param {ServiceCollectionFieldInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createServiceCollectionField(serviceCollectionId: string, body?: ServiceCollectionFieldInput, options?: any): AxiosPromise<object> {
            return localVarFp.createServiceCollectionField(serviceCollectionId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a Service Collection
         * @param {string} serviceCollectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteServiceCollection(serviceCollectionId: string, options?: any): AxiosPromise<object> {
            return localVarFp.deleteServiceCollection(serviceCollectionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete field from Service Collection
         * @param {string} serviceCollectionId 
         * @param {string} fieldId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteServiceCollectionField(serviceCollectionId: string, fieldId: string, options?: any): AxiosPromise<object> {
            return localVarFp.deleteServiceCollectionField(serviceCollectionId, fieldId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Service Collection Services
         * @param {string} serviceCollectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServiceCollectionServices(serviceCollectionId: string, options?: any): AxiosPromise<Array<ServiceCollectionService>> {
            return localVarFp.listServiceCollectionServices(serviceCollectionId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all service collections
         * @summary List all Service Collections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServiceCollections(options?: any): AxiosPromise<Array<ServiceCollection>> {
            return localVarFp.listServiceCollections(options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all service collections that a current user has access to through their Service roles
         * @summary List Service Collections for user
         * @param {string} [serviceId]  Only return collections containing the specified service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserServiceCollections(serviceId?: string, options?: any): AxiosPromise<Array<ServiceCollection>> {
            return localVarFp.listUserServiceCollections(serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove service from service collection
         * @param {string} serviceCollectionId 
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeServiceFromServiceCollection(serviceCollectionId: string, serviceId: string, options?: any): AxiosPromise<object> {
            return localVarFp.removeServiceFromServiceCollection(serviceCollectionId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Service Collection
         * @param {string} serviceCollectionId 
         * @param {ServiceCollectionInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateServiceCollection(serviceCollectionId: string, body?: ServiceCollectionInput, options?: any): AxiosPromise<object> {
            return localVarFp.updateServiceCollection(serviceCollectionId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update service collection field
         * @param {string} serviceCollectionId 
         * @param {string} fieldId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateServiceCollectionField(serviceCollectionId: string, fieldId: string, options?: any): AxiosPromise<object> {
            return localVarFp.updateServiceCollectionField(serviceCollectionId, fieldId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update service for service collection
         * @param {string} serviceCollectionId 
         * @param {string} serviceId 
         * @param {ServiceCollectionServiceInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateServiceForServiceCollection(serviceCollectionId: string, serviceId: string, body?: ServiceCollectionServiceInput, options?: any): AxiosPromise<object> {
            return localVarFp.updateServiceForServiceCollection(serviceCollectionId, serviceId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServiceCollectionsApi - object-oriented interface
 * @export
 * @class ServiceCollectionsApi
 * @extends {BaseAPI}
 */
export class ServiceCollectionsApi extends BaseAPI {
    /**
     * 
     * @summary Add service to service collection
     * @param {string} serviceCollectionId 
     * @param {string} serviceId 
     * @param {ServiceCollectionServiceInput} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceCollectionsApi
     */
    public addServiceToServiceCollection(serviceCollectionId: string, serviceId: string, body?: ServiceCollectionServiceInput, options?: any) {
        return ServiceCollectionsApiFp(this.configuration).addServiceToServiceCollection(serviceCollectionId, serviceId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a Service Collection
     * @param {ServiceCollectionInput} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceCollectionsApi
     */
    public createServiceCollection(body?: ServiceCollectionInput, options?: any) {
        return ServiceCollectionsApiFp(this.configuration).createServiceCollection(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Service Collection Field
     * @param {string} serviceCollectionId 
     * @param {ServiceCollectionFieldInput} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceCollectionsApi
     */
    public createServiceCollectionField(serviceCollectionId: string, body?: ServiceCollectionFieldInput, options?: any) {
        return ServiceCollectionsApiFp(this.configuration).createServiceCollectionField(serviceCollectionId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a Service Collection
     * @param {string} serviceCollectionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceCollectionsApi
     */
    public deleteServiceCollection(serviceCollectionId: string, options?: any) {
        return ServiceCollectionsApiFp(this.configuration).deleteServiceCollection(serviceCollectionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete field from Service Collection
     * @param {string} serviceCollectionId 
     * @param {string} fieldId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceCollectionsApi
     */
    public deleteServiceCollectionField(serviceCollectionId: string, fieldId: string, options?: any) {
        return ServiceCollectionsApiFp(this.configuration).deleteServiceCollectionField(serviceCollectionId, fieldId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Service Collection Services
     * @param {string} serviceCollectionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceCollectionsApi
     */
    public listServiceCollectionServices(serviceCollectionId: string, options?: any) {
        return ServiceCollectionsApiFp(this.configuration).listServiceCollectionServices(serviceCollectionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all service collections
     * @summary List all Service Collections
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceCollectionsApi
     */
    public listServiceCollections(options?: any) {
        return ServiceCollectionsApiFp(this.configuration).listServiceCollections(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all service collections that a current user has access to through their Service roles
     * @summary List Service Collections for user
     * @param {string} [serviceId]  Only return collections containing the specified service
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceCollectionsApi
     */
    public listUserServiceCollections(serviceId?: string, options?: any) {
        return ServiceCollectionsApiFp(this.configuration).listUserServiceCollections(serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove service from service collection
     * @param {string} serviceCollectionId 
     * @param {string} serviceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceCollectionsApi
     */
    public removeServiceFromServiceCollection(serviceCollectionId: string, serviceId: string, options?: any) {
        return ServiceCollectionsApiFp(this.configuration).removeServiceFromServiceCollection(serviceCollectionId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Service Collection
     * @param {string} serviceCollectionId 
     * @param {ServiceCollectionInput} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceCollectionsApi
     */
    public updateServiceCollection(serviceCollectionId: string, body?: ServiceCollectionInput, options?: any) {
        return ServiceCollectionsApiFp(this.configuration).updateServiceCollection(serviceCollectionId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update service collection field
     * @param {string} serviceCollectionId 
     * @param {string} fieldId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceCollectionsApi
     */
    public updateServiceCollectionField(serviceCollectionId: string, fieldId: string, options?: any) {
        return ServiceCollectionsApiFp(this.configuration).updateServiceCollectionField(serviceCollectionId, fieldId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update service for service collection
     * @param {string} serviceCollectionId 
     * @param {string} serviceId 
     * @param {ServiceCollectionServiceInput} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceCollectionsApi
     */
    public updateServiceForServiceCollection(serviceCollectionId: string, serviceId: string, body?: ServiceCollectionServiceInput, options?: any) {
        return ServiceCollectionsApiFp(this.configuration).updateServiceForServiceCollection(serviceCollectionId, serviceId, body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ServicesApi - axios parameter creator
 * @export
 */
export const ServicesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add feature to service
         * @param {string} serviceId 
         * @param {string} featureCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFeature: async (serviceId: string, featureCode: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('addFeature', 'serviceId', serviceId)
            // verify required parameter 'featureCode' is not null or undefined
            assertParamExists('addFeature', 'featureCode', featureCode)
            const localVarPath = `/services/{serviceId}/features/{featureCode}`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)))
                .replace(`{${"featureCode"}}`, encodeURIComponent(String(featureCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Provision one or more accounts & services
         * @param {InlineObject7} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provision: async (body?: InlineObject7, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/provision`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove feature from service
         * @param {string} serviceId 
         * @param {string} featureCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeFeature: async (serviceId: string, featureCode: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('removeFeature', 'serviceId', serviceId)
            // verify required parameter 'featureCode' is not null or undefined
            assertParamExists('removeFeature', 'featureCode', featureCode)
            const localVarPath = `/services/{serviceId}/features/{featureCode}`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)))
                .replace(`{${"featureCode"}}`, encodeURIComponent(String(featureCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add service channel
         * @param {string} serviceId 
         * @param {ServiceChannelInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesServiceIdChannelsPost: async (serviceId: string, body?: ServiceChannelInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('servicesServiceIdChannelsPost', 'serviceId', serviceId)
            const localVarPath = `/services/{serviceId}/channels`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return events by service
         * @param {string} serviceId 
         * @param {string} [start] 
         * @param {string} [end] 
         * @param {boolean} [groupByContact] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesServiceIdEventsGet: async (serviceId: string, start?: string, end?: string, groupByContact?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('servicesServiceIdEventsGet', 'serviceId', serviceId)
            const localVarPath = `/services/{serviceId}/events`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString() :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString() :
                    end;
            }

            if (groupByContact !== undefined) {
                localVarQueryParameter['group_by_contact'] = groupByContact;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove service code from a service
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesServiceIdServiceCodeDelete: async (serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('servicesServiceIdServiceCodeDelete', 'serviceId', serviceId)
            const localVarPath = `/services/{serviceId}/service_code`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add/Update service code to service
         * @param {string} serviceId 
         * @param {string} [serviceCode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesServiceIdServiceCodePost: async (serviceId: string, serviceCode?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('servicesServiceIdServiceCodePost', 'serviceId', serviceId)
            const localVarPath = `/services/{serviceId}/service_code`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Token", configuration)

            if (serviceCode !== undefined && serviceCode !== null) {
                localVarHeaderParameter['service_code'] = String(serviceCode);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServicesApi - functional programming interface
 * @export
 */
export const ServicesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServicesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add feature to service
         * @param {string} serviceId 
         * @param {string} featureCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addFeature(serviceId: string, featureCode: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addFeature(serviceId, featureCode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Provision one or more accounts & services
         * @param {InlineObject7} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async provision(body?: InlineObject7, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.provision(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove feature from service
         * @param {string} serviceId 
         * @param {string} featureCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeFeature(serviceId: string, featureCode: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeFeature(serviceId, featureCode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add service channel
         * @param {string} serviceId 
         * @param {ServiceChannelInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async servicesServiceIdChannelsPost(serviceId: string, body?: ServiceChannelInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicesServiceIdChannelsPost(serviceId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Return events by service
         * @param {string} serviceId 
         * @param {string} [start] 
         * @param {string} [end] 
         * @param {boolean} [groupByContact] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async servicesServiceIdEventsGet(serviceId: string, start?: string, end?: string, groupByContact?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicesServiceIdEventsGet(serviceId, start, end, groupByContact, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove service code from a service
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async servicesServiceIdServiceCodeDelete(serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicesServiceIdServiceCodeDelete(serviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add/Update service code to service
         * @param {string} serviceId 
         * @param {string} [serviceCode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async servicesServiceIdServiceCodePost(serviceId: string, serviceCode?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicesServiceIdServiceCodePost(serviceId, serviceCode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ServicesApi - factory interface
 * @export
 */
export const ServicesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServicesApiFp(configuration)
    return {
        /**
         * 
         * @summary Add feature to service
         * @param {string} serviceId 
         * @param {string} featureCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFeature(serviceId: string, featureCode: string, options?: any): AxiosPromise<object> {
            return localVarFp.addFeature(serviceId, featureCode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Provision one or more accounts & services
         * @param {InlineObject7} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provision(body?: InlineObject7, options?: any): AxiosPromise<object> {
            return localVarFp.provision(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove feature from service
         * @param {string} serviceId 
         * @param {string} featureCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeFeature(serviceId: string, featureCode: string, options?: any): AxiosPromise<object> {
            return localVarFp.removeFeature(serviceId, featureCode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add service channel
         * @param {string} serviceId 
         * @param {ServiceChannelInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesServiceIdChannelsPost(serviceId: string, body?: ServiceChannelInput, options?: any): AxiosPromise<object> {
            return localVarFp.servicesServiceIdChannelsPost(serviceId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return events by service
         * @param {string} serviceId 
         * @param {string} [start] 
         * @param {string} [end] 
         * @param {boolean} [groupByContact] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesServiceIdEventsGet(serviceId: string, start?: string, end?: string, groupByContact?: boolean, options?: any): AxiosPromise<object> {
            return localVarFp.servicesServiceIdEventsGet(serviceId, start, end, groupByContact, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove service code from a service
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesServiceIdServiceCodeDelete(serviceId: string, options?: any): AxiosPromise<object> {
            return localVarFp.servicesServiceIdServiceCodeDelete(serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add/Update service code to service
         * @param {string} serviceId 
         * @param {string} [serviceCode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesServiceIdServiceCodePost(serviceId: string, serviceCode?: string, options?: any): AxiosPromise<object> {
            return localVarFp.servicesServiceIdServiceCodePost(serviceId, serviceCode, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServicesApi - object-oriented interface
 * @export
 * @class ServicesApi
 * @extends {BaseAPI}
 */
export class ServicesApi extends BaseAPI {
    /**
     * 
     * @summary Add feature to service
     * @param {string} serviceId 
     * @param {string} featureCode 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicesApi
     */
    public addFeature(serviceId: string, featureCode: string, options?: any) {
        return ServicesApiFp(this.configuration).addFeature(serviceId, featureCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Provision one or more accounts & services
     * @param {InlineObject7} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicesApi
     */
    public provision(body?: InlineObject7, options?: any) {
        return ServicesApiFp(this.configuration).provision(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove feature from service
     * @param {string} serviceId 
     * @param {string} featureCode 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicesApi
     */
    public removeFeature(serviceId: string, featureCode: string, options?: any) {
        return ServicesApiFp(this.configuration).removeFeature(serviceId, featureCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add service channel
     * @param {string} serviceId 
     * @param {ServiceChannelInput} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicesApi
     */
    public servicesServiceIdChannelsPost(serviceId: string, body?: ServiceChannelInput, options?: any) {
        return ServicesApiFp(this.configuration).servicesServiceIdChannelsPost(serviceId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return events by service
     * @param {string} serviceId 
     * @param {string} [start] 
     * @param {string} [end] 
     * @param {boolean} [groupByContact] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicesApi
     */
    public servicesServiceIdEventsGet(serviceId: string, start?: string, end?: string, groupByContact?: boolean, options?: any) {
        return ServicesApiFp(this.configuration).servicesServiceIdEventsGet(serviceId, start, end, groupByContact, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove service code from a service
     * @param {string} serviceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicesApi
     */
    public servicesServiceIdServiceCodeDelete(serviceId: string, options?: any) {
        return ServicesApiFp(this.configuration).servicesServiceIdServiceCodeDelete(serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add/Update service code to service
     * @param {string} serviceId 
     * @param {string} [serviceCode] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicesApi
     */
    public servicesServiceIdServiceCodePost(serviceId: string, serviceCode?: string, options?: any) {
        return ServicesApiFp(this.configuration).servicesServiceIdServiceCodePost(serviceId, serviceCode, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TagsApi - axios parameter creator
 * @export
 */
export const TagsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Tag
         * @param {string} serviceId 
         * @param {TagInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTag: async (serviceId: string, body?: TagInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('createTag', 'serviceId', serviceId)
            const localVarPath = `/services/{serviceId}/tags`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Tag
         * @param {string} serviceId 
         * @param {string} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag: async (serviceId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('deleteTag', 'serviceId', serviceId)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('deleteTag', 'tagId', tagId)
            const localVarPath = `/services/{serviceId}/tags/{tagId}`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Tag
         * @param {string} serviceId 
         * @param {string} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTag: async (serviceId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('getTag', 'serviceId', serviceId)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('getTag', 'tagId', tagId)
            const localVarPath = `/services/{serviceId}/tags/{tagId}`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Tags
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTags: async (serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('listTags', 'serviceId', serviceId)
            const localVarPath = `/services/{serviceId}/tags`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Tag
         * @param {string} serviceId 
         * @param {string} tagId 
         * @param {TagInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTag: async (serviceId: string, tagId: string, body?: TagInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('updateTag', 'serviceId', serviceId)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('updateTag', 'tagId', tagId)
            const localVarPath = `/services/{serviceId}/tags/{tagId}`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagsApi - functional programming interface
 * @export
 */
export const TagsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TagsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Tag
         * @param {string} serviceId 
         * @param {TagInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTag(serviceId: string, body?: TagInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTag(serviceId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Tag
         * @param {string} serviceId 
         * @param {string} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTag(serviceId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTag(serviceId, tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Tag
         * @param {string} serviceId 
         * @param {string} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTag(serviceId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTag(serviceId, tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Tags
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTags(serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTags(serviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update Tag
         * @param {string} serviceId 
         * @param {string} tagId 
         * @param {TagInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTag(serviceId: string, tagId: string, body?: TagInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTag(serviceId, tagId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TagsApi - factory interface
 * @export
 */
export const TagsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TagsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Tag
         * @param {string} serviceId 
         * @param {TagInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTag(serviceId: string, body?: TagInput, options?: any): AxiosPromise<void> {
            return localVarFp.createTag(serviceId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Tag
         * @param {string} serviceId 
         * @param {string} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag(serviceId: string, tagId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTag(serviceId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Tag
         * @param {string} serviceId 
         * @param {string} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTag(serviceId: string, tagId: string, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.getTag(serviceId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Tags
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTags(serviceId: string, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.listTags(serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Tag
         * @param {string} serviceId 
         * @param {string} tagId 
         * @param {TagInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTag(serviceId: string, tagId: string, body?: TagInput, options?: any): AxiosPromise<void> {
            return localVarFp.updateTag(serviceId, tagId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TagsApi - object-oriented interface
 * @export
 * @class TagsApi
 * @extends {BaseAPI}
 */
export class TagsApi extends BaseAPI {
    /**
     * 
     * @summary Create Tag
     * @param {string} serviceId 
     * @param {TagInput} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public createTag(serviceId: string, body?: TagInput, options?: any) {
        return TagsApiFp(this.configuration).createTag(serviceId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Tag
     * @param {string} serviceId 
     * @param {string} tagId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public deleteTag(serviceId: string, tagId: string, options?: any) {
        return TagsApiFp(this.configuration).deleteTag(serviceId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Tag
     * @param {string} serviceId 
     * @param {string} tagId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public getTag(serviceId: string, tagId: string, options?: any) {
        return TagsApiFp(this.configuration).getTag(serviceId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Tags
     * @param {string} serviceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public listTags(serviceId: string, options?: any) {
        return TagsApiFp(this.configuration).listTags(serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Tag
     * @param {string} serviceId 
     * @param {string} tagId 
     * @param {TagInput} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public updateTag(serviceId: string, tagId: string, body?: TagInput, options?: any) {
        return TagsApiFp(this.configuration).updateTag(serviceId, tagId, body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TemplatesApi - axios parameter creator
 * @export
 */
export const TemplatesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create service template
         * @summary Create a template
         * @param {string} serviceId 
         * @param {TemplateInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTemplate: async (serviceId: string, body?: TemplateInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('createTemplate', 'serviceId', serviceId)
            const localVarPath = `/services/{serviceId}/templates`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete template
         * @param {string} serviceId 
         * @param {string} templateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTemplate: async (serviceId: string, templateId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('deleteTemplate', 'serviceId', serviceId)
            // verify required parameter 'templateId' is not null or undefined
            assertParamExists('deleteTemplate', 'templateId', templateId)
            const localVarPath = `/services/{serviceId}/templates/{templateId}`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)))
                .replace(`{${"templateId"}}`, encodeURIComponent(String(templateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a template
         * @param {string} serviceId 
         * @param {string} templateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplate: async (serviceId: string, templateId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('getTemplate', 'serviceId', serviceId)
            // verify required parameter 'templateId' is not null or undefined
            assertParamExists('getTemplate', 'templateId', templateId)
            const localVarPath = `/services/{serviceId}/templates/{templateId}`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)))
                .replace(`{${"templateId"}}`, encodeURIComponent(String(templateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List service templates
         * @summary List Templates
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTemplates: async (serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('listTemplates', 'serviceId', serviceId)
            const localVarPath = `/services/{serviceId}/templates`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update template
         * @param {string} serviceId 
         * @param {string} templateId 
         * @param {TemplateInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTemplate: async (serviceId: string, templateId: string, body?: TemplateInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('updateTemplate', 'serviceId', serviceId)
            // verify required parameter 'templateId' is not null or undefined
            assertParamExists('updateTemplate', 'templateId', templateId)
            const localVarPath = `/services/{serviceId}/templates/{templateId}`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)))
                .replace(`{${"templateId"}}`, encodeURIComponent(String(templateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TemplatesApi - functional programming interface
 * @export
 */
export const TemplatesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TemplatesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create service template
         * @summary Create a template
         * @param {string} serviceId 
         * @param {TemplateInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTemplate(serviceId: string, body?: TemplateInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTemplate(serviceId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete template
         * @param {string} serviceId 
         * @param {string} templateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTemplate(serviceId: string, templateId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTemplate(serviceId, templateId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a template
         * @param {string} serviceId 
         * @param {string} templateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTemplate(serviceId: string, templateId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Template>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTemplate(serviceId, templateId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List service templates
         * @summary List Templates
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTemplates(serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Template>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTemplates(serviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update template
         * @param {string} serviceId 
         * @param {string} templateId 
         * @param {TemplateInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTemplate(serviceId: string, templateId: string, body?: TemplateInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTemplate(serviceId, templateId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TemplatesApi - factory interface
 * @export
 */
export const TemplatesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TemplatesApiFp(configuration)
    return {
        /**
         * Create service template
         * @summary Create a template
         * @param {string} serviceId 
         * @param {TemplateInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTemplate(serviceId: string, body?: TemplateInput, options?: any): AxiosPromise<void> {
            return localVarFp.createTemplate(serviceId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete template
         * @param {string} serviceId 
         * @param {string} templateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTemplate(serviceId: string, templateId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTemplate(serviceId, templateId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a template
         * @param {string} serviceId 
         * @param {string} templateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplate(serviceId: string, templateId: string, options?: any): AxiosPromise<Template> {
            return localVarFp.getTemplate(serviceId, templateId, options).then((request) => request(axios, basePath));
        },
        /**
         * List service templates
         * @summary List Templates
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTemplates(serviceId: string, options?: any): AxiosPromise<Array<Template>> {
            return localVarFp.listTemplates(serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update template
         * @param {string} serviceId 
         * @param {string} templateId 
         * @param {TemplateInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTemplate(serviceId: string, templateId: string, body?: TemplateInput, options?: any): AxiosPromise<void> {
            return localVarFp.updateTemplate(serviceId, templateId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TemplatesApi - object-oriented interface
 * @export
 * @class TemplatesApi
 * @extends {BaseAPI}
 */
export class TemplatesApi extends BaseAPI {
    /**
     * Create service template
     * @summary Create a template
     * @param {string} serviceId 
     * @param {TemplateInput} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public createTemplate(serviceId: string, body?: TemplateInput, options?: any) {
        return TemplatesApiFp(this.configuration).createTemplate(serviceId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete template
     * @param {string} serviceId 
     * @param {string} templateId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public deleteTemplate(serviceId: string, templateId: string, options?: any) {
        return TemplatesApiFp(this.configuration).deleteTemplate(serviceId, templateId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a template
     * @param {string} serviceId 
     * @param {string} templateId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public getTemplate(serviceId: string, templateId: string, options?: any) {
        return TemplatesApiFp(this.configuration).getTemplate(serviceId, templateId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List service templates
     * @summary List Templates
     * @param {string} serviceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public listTemplates(serviceId: string, options?: any) {
        return TemplatesApiFp(this.configuration).listTemplates(serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update template
     * @param {string} serviceId 
     * @param {string} templateId 
     * @param {TemplateInput} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public updateTemplate(serviceId: string, templateId: string, body?: TemplateInput, options?: any) {
        return TemplatesApiFp(this.configuration).updateTemplate(serviceId, templateId, body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get Current User Info
         * @summary Get the current User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List account access history
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAccountAccess: async (page?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/account-access`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Grant account access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        grantUserAccountAccess: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/account-access`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Users
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers: async (serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('listUsers', 'serviceId', serviceId)
            const localVarPath = `/services/{serviceId}/users`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Revoke account access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeUserAccountAccess: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/account-access`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update Current User
         * @summary Update the current User
         * @param {UpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMe: async (body?: UpdateRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Get Current User Info
         * @summary Get the current User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMe(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMe(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List account access history
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserAccountAccess(page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20010>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserAccountAccess(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Grant account access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async grantUserAccountAccess(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.grantUserAccountAccess(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Users
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUsers(serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUsers(serviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Revoke account access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async revokeUserAccountAccess(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.revokeUserAccountAccess(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update Current User
         * @summary Update the current User
         * @param {UpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMe(body?: UpdateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMe(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Get Current User Info
         * @summary Get the current User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe(options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.getMe(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List account access history
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAccountAccess(page?: number, options?: any): AxiosPromise<InlineResponse20010> {
            return localVarFp.getUserAccountAccess(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Grant account access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        grantUserAccountAccess(options?: any): AxiosPromise<object> {
            return localVarFp.grantUserAccountAccess(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Users
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers(serviceId: string, options?: any): AxiosPromise<Array<User>> {
            return localVarFp.listUsers(serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Revoke account access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeUserAccountAccess(options?: any): AxiosPromise<object> {
            return localVarFp.revokeUserAccountAccess(options).then((request) => request(axios, basePath));
        },
        /**
         * Update Current User
         * @summary Update the current User
         * @param {UpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMe(body?: UpdateRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateMe(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Get Current User Info
     * @summary Get the current User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getMe(options?: any) {
        return UsersApiFp(this.configuration).getMe(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List account access history
     * @param {number} [page] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserAccountAccess(page?: number, options?: any) {
        return UsersApiFp(this.configuration).getUserAccountAccess(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Grant account access
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public grantUserAccountAccess(options?: any) {
        return UsersApiFp(this.configuration).grantUserAccountAccess(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Users
     * @param {string} serviceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public listUsers(serviceId: string, options?: any) {
        return UsersApiFp(this.configuration).listUsers(serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Revoke account access
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public revokeUserAccountAccess(options?: any) {
        return UsersApiFp(this.configuration).revokeUserAccountAccess(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update Current User
     * @summary Update the current User
     * @param {UpdateRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateMe(body?: UpdateRequest, options?: any) {
        return UsersApiFp(this.configuration).updateMe(body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WebhooksApi - axios parameter creator
 * @export
 */
export const WebhooksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a Webhook
         * @param {string} serviceId 
         * @param {WebhookInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook: async (serviceId: string, body?: WebhookInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('createWebhook', 'serviceId', serviceId)
            const localVarPath = `/services/{serviceId}/webhooks`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a Webhook
         * @param {string} serviceId 
         * @param {string} webhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook: async (serviceId: string, webhookId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('deleteWebhook', 'serviceId', serviceId)
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('deleteWebhook', 'webhookId', webhookId)
            const localVarPath = `/services/{serviceId}/webhooks/{webhookId}`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)))
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a webhook
         * @param {string} serviceId 
         * @param {string} webhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook: async (serviceId: string, webhookId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('getWebhook', 'serviceId', serviceId)
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('getWebhook', 'webhookId', webhookId)
            const localVarPath = `/services/{serviceId}/webhooks/{webhookId}`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)))
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Webhooks
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWebhooks: async (serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('listWebhooks', 'serviceId', serviceId)
            const localVarPath = `/services/{serviceId}/webhooks`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a Webhook
         * @param {string} serviceId 
         * @param {string} webhookId 
         * @param {WebhookInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesServiceIdWebhooksWebhookIdPost: async (serviceId: string, webhookId: string, body?: WebhookInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('servicesServiceIdWebhooksWebhookIdPost', 'serviceId', serviceId)
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('servicesServiceIdWebhooksWebhookIdPost', 'webhookId', webhookId)
            const localVarPath = `/services/{serviceId}/webhooks/{webhookId}`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)))
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Webhook
         * @param {string} serviceId 
         * @param {string} webhookId 
         * @param {WebhookInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook: async (serviceId: string, webhookId: string, body?: WebhookInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('updateWebhook', 'serviceId', serviceId)
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('updateWebhook', 'webhookId', webhookId)
            const localVarPath = `/services/{serviceId}/webhooks/{webhookId}`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)))
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets 
         * @summary Update All Webhooks
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhooks: async (serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('updateWebhooks', 'serviceId', serviceId)
            const localVarPath = `/services/{serviceId}/webhooks`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhooksApi - functional programming interface
 * @export
 */
export const WebhooksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebhooksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a Webhook
         * @param {string} serviceId 
         * @param {WebhookInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWebhook(serviceId: string, body?: WebhookInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWebhook(serviceId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a Webhook
         * @param {string} serviceId 
         * @param {string} webhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWebhook(serviceId: string, webhookId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWebhook(serviceId, webhookId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a webhook
         * @param {string} serviceId 
         * @param {string} webhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWebhook(serviceId: string, webhookId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWebhook(serviceId, webhookId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Webhooks
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWebhooks(serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Webhook>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWebhooks(serviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a Webhook
         * @param {string} serviceId 
         * @param {string} webhookId 
         * @param {WebhookInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async servicesServiceIdWebhooksWebhookIdPost(serviceId: string, webhookId: string, body?: WebhookInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicesServiceIdWebhooksWebhookIdPost(serviceId, webhookId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a Webhook
         * @param {string} serviceId 
         * @param {string} webhookId 
         * @param {WebhookInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWebhook(serviceId: string, webhookId: string, body?: WebhookInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWebhook(serviceId, webhookId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sets 
         * @summary Update All Webhooks
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWebhooks(serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WebhookInput>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWebhooks(serviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WebhooksApi - factory interface
 * @export
 */
export const WebhooksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebhooksApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a Webhook
         * @param {string} serviceId 
         * @param {WebhookInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook(serviceId: string, body?: WebhookInput, options?: any): AxiosPromise<object> {
            return localVarFp.createWebhook(serviceId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a Webhook
         * @param {string} serviceId 
         * @param {string} webhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(serviceId: string, webhookId: string, options?: any): AxiosPromise<object> {
            return localVarFp.deleteWebhook(serviceId, webhookId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a webhook
         * @param {string} serviceId 
         * @param {string} webhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook(serviceId: string, webhookId: string, options?: any): AxiosPromise<Webhook> {
            return localVarFp.getWebhook(serviceId, webhookId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Webhooks
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWebhooks(serviceId: string, options?: any): AxiosPromise<Array<Webhook>> {
            return localVarFp.listWebhooks(serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a Webhook
         * @param {string} serviceId 
         * @param {string} webhookId 
         * @param {WebhookInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesServiceIdWebhooksWebhookIdPost(serviceId: string, webhookId: string, body?: WebhookInput, options?: any): AxiosPromise<object> {
            return localVarFp.servicesServiceIdWebhooksWebhookIdPost(serviceId, webhookId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Webhook
         * @param {string} serviceId 
         * @param {string} webhookId 
         * @param {WebhookInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook(serviceId: string, webhookId: string, body?: WebhookInput, options?: any): AxiosPromise<object> {
            return localVarFp.updateWebhook(serviceId, webhookId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets 
         * @summary Update All Webhooks
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhooks(serviceId: string, options?: any): AxiosPromise<Array<WebhookInput>> {
            return localVarFp.updateWebhooks(serviceId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebhooksApi - object-oriented interface
 * @export
 * @class WebhooksApi
 * @extends {BaseAPI}
 */
export class WebhooksApi extends BaseAPI {
    /**
     * 
     * @summary Create a Webhook
     * @param {string} serviceId 
     * @param {WebhookInput} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public createWebhook(serviceId: string, body?: WebhookInput, options?: any) {
        return WebhooksApiFp(this.configuration).createWebhook(serviceId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a Webhook
     * @param {string} serviceId 
     * @param {string} webhookId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public deleteWebhook(serviceId: string, webhookId: string, options?: any) {
        return WebhooksApiFp(this.configuration).deleteWebhook(serviceId, webhookId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a webhook
     * @param {string} serviceId 
     * @param {string} webhookId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public getWebhook(serviceId: string, webhookId: string, options?: any) {
        return WebhooksApiFp(this.configuration).getWebhook(serviceId, webhookId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Webhooks
     * @param {string} serviceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public listWebhooks(serviceId: string, options?: any) {
        return WebhooksApiFp(this.configuration).listWebhooks(serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a Webhook
     * @param {string} serviceId 
     * @param {string} webhookId 
     * @param {WebhookInput} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public servicesServiceIdWebhooksWebhookIdPost(serviceId: string, webhookId: string, body?: WebhookInput, options?: any) {
        return WebhooksApiFp(this.configuration).servicesServiceIdWebhooksWebhookIdPost(serviceId, webhookId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Webhook
     * @param {string} serviceId 
     * @param {string} webhookId 
     * @param {WebhookInput} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public updateWebhook(serviceId: string, webhookId: string, body?: WebhookInput, options?: any) {
        return WebhooksApiFp(this.configuration).updateWebhook(serviceId, webhookId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sets 
     * @summary Update All Webhooks
     * @param {string} serviceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public updateWebhooks(serviceId: string, options?: any) {
        return WebhooksApiFp(this.configuration).updateWebhooks(serviceId, options).then((request) => request(this.axios, this.basePath));
    }
}


